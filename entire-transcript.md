Course Overview
Hi. This is Scott Allen, and welcome to C# Fundamentals. The goal of this course is to give you all the knowledge that you need to start being productive with the C# programming language. C# has consistently been one of the top three programming languages to learn because it's used widely in the industry and it's an expressive and powerful language. In this course, we're going to learn about the C# language, as well as the .NET Framework that you'll use when building software with C#. We are going to build a gradebook application to store grades from a class of students, and along the way we'll learn how to define classes and methods in C#, as well as learn essential topics like error handling. We'll also discuss object‑oriented programming with C#, and I'll give you a list of my best practices for the language before we leave the course. By the end of the course, you'll be ready to contribute to your own projects with C#, and you'll also be prepared to move on to some additional C# courses, covering features in more detail, like generics in C# and Language Integrated Query, or LINQ, with C#. Now, I do assume you already have a small amount of basic programming knowledge before you start this course, so hopefully you've already done some work with true and false and Boolean logic, and you've seen how to write a loop in some other language. If so, we're ready to start.

Introducing C# and .NET
Introduction
Hi. This is Scott, and welcome to my C# course. In this course, I want to teach you how to use the C# programming language effectively, but this is not an introduction to programming. I expect you already know a little bit about programming. So if I talk about a loop or an array, I hope you already know a little bit about those concepts from another programming environment. My goal is to teach you about the C# language, and I want you to follow along with the demos that I do in the videos because I believe that typing and writing code is about 30% of what you have to do to learn a language. Another 30% is experimenting with the code that you write by changing that code and really understanding how it works. The last 40% of what you do to learn a language is to read other people's source code. Throughout this course, we're going to build a small application to store the grades for a class of students, and by the time we're done, you'll be able to create your own projects based on your own ideas. Since I want you to follow along, let's talk about the tools I'm going to use.

Downloading .NET for Windows, macOS, and Linux
In this course when I'm demoing the C# language, I'm going to be using the language on top of a runtime and a framework known as .NET Core. In order for you to follow along, you are also going to need to download what is known as the .NET Core SDK, or software development kit. This SDK provides all of the tools that I need to convert a program written with the C# language into a program that I can run on my computer. So if you go out and do a search for .NET downloads, you should be able to find this page on the Microsoft.com website with links to download .NET Core, and .NET Core is available for different operating systems, Windows, Linux, and macOS. So .NET Core runs nearly everywhere, and you just want to look for the link that allows you to download the .NET Core SDK. Now, in this course, I'm going to be using a specific version of .NET Core. I'm going to use the latest released version, which is 2.2, and all the code that I'm going to write in this course I expect to work in future versions of .NET Core and C#. So if you want to download the latest version of .NET Core, if there's a later version available by the time you watch this video, then feel free to download a later version. But, if you're very conservative and you want to use the exact same version of .NET Core that I'm using, because there always will be small changes, but you can always find older versions of .NET Core in the download archives from this page. So just look for Archives, go to that page, and older versions of .NET Core will be available. So if we're currently on .NET Core 5.6, you'll be able to go back and find a download for the .NET Core 2.2 SDK. Now, in addition to the SDK, there's just one other tool that I need. I need some sort of editor, somewhere where I can write and type in C# code, and in this course I'm going to be using Visual Studio Code. Visual Studio Code, just like .NET Core, is available on Windows and macOS and Linux, so you can use Visual Studio Code as an editor with the C# language on just about any platform. If you do a search for Visual Studio Code, or VS Code, that should bring you to this web page at Visualstudio.com, and you should be able to find a Download button. And from there, click on the download associated with the platform that you're using. On this machine that I'm using, I've already installed Visual Studio Code, I've already installed the .NET Core SDK, so let's start a journey towards writing our first program. Before we start writing our first program, however, I do just want to spend a little bit of time talking about the environment that we'll be using, which is .NET Core.

Understanding .NET and .NET Core
This is a course about the C# language, so we will be creating software using the C# language. But what is going to run our software? Because I cannot just put C# code into a file and expect an operating system or a CPU to understand the instructions inside. There has to be a runtime or a framework that can take my C# code and tell the computer what to do. And that framework we're looking for with C# is called .NET. Now, if you've done any reading or research about the C# language already, you might've come across two different .NETs in the world, and I just want to take a quick moment to explain the different types of .NET to give you a better understanding of what we'll be doing. When people refer to .NET, just .NET, or they refer to the .NET Framework, they are probably talking about a version of .NET that works only on Windows machines. This is the .NET Framework that has been around since about 2001, and it is the .NET Framework that often comes preinstalled on Windows, and it's a framework that is authored and supported by Microsoft. .NET Core has been around for just a few years, but .NET Core refers to a .NET that is completely open source and works across various platforms like Windows, macOS, Linux, and even runs on a small Raspberry Pi computer. Both .NET and .NET Core support the C# language, but it is .NET Core that you probably want to be using if you can in any new projects today. .NET Core is certainly what we're going to use in this course. So what is inside of .NET and .NET Core? How did they support the C# language? Let's talk about that next.

Understanding the .NET Runtime and Framework
We're going to write some C# code in just a moment, but as I mentioned before, I cannot just give my C# code to the computer and expect the computer to execute my program. There has to be some additional software in place that knows how to translate the C# code into instructions for my machine, my operating system, and my CPU. This is true for any high‑level programming language, Java, Ruby, JavaScript, Python, they all need additional software to execute the instructions that you are writing in that language. As I mentioned for C#, this software is what we call .NET, and you can really break down .NET into two pieces. First, there is what we call the CLR, which is short for Common Language Runtime. That's a fancy term, so all I want you to remember is that .NET is a runtime, which means .NET provides a space for you to run your programs in C#. So .NET knows how to bring your program to life and manage memory for that program and send instructions to the Intel or AMD or ARM processor that's in your computer. And actually, .NET provides a space to run not just C# programs, but there's a number of other languages that work on top of the .NET runtime, including Visual Basic .NET and F# and others. The second piece of .NET is what we sometimes call the FCL, or Framework Class Library, but there are lots of names that you might hear for this part of .NET, including Base Class Library. But the most important word to remember is the term library. In addition to a runtime, .NET also provides a library of code that is already written and tested by other developers, Microsoft developers and non‑Microsoft developers in .NET Core, since .NET Core is a true open source project. You can use the code from this library in your C# program to perform common activities, like if you need to communicate over the network with HTTP or if you need to encrypt and sign a message or you need to open a file, those are all activities that are already written for you, and you can take advantage of them from your program so that you don't have to spend your time writing all the low‑level code that is already in the .NET library. So now that we know a bit about .NET, let's use a tool from the .NET SDK to create our first project. The SDK that you downloaded, by the way, includes a .NET Core runtime and all the files that you need for the .NET Core library, as well as some additional tools that make developing software in .NET easier, and that's why we call it an SDK, a software development kit. Let's take a look.

Using the .NET Command Line Interface
Once you have the .NET Core SDK installed, you should be able to open a command prompt to use something we call the .NET CLI. CLI is short for command‑line interface. So you can open a command prompt or a shell or a terminal. Really depends on what operating system you're on. And if you're on Windows and you've never opened a command prompt, go to the Start menu, type cmd, and one of the entries that should be available is command prompt. In this course, we only need to perform some very simple operations in the command prompt, but what I want to do is interact with a tool known as the .NET CLI. The name of the program that I want to run is dotnet, and after you've installed the .NET Core SDK, this program should be available from any place that you are on the file system on your computer. In other words, this tool should be in your path so that I can run this program from anywhere. And you can see when I execute .NET, the program is saying, look, I either expect some options or I expect a path to an application. Let's try some options first. One of the options I can pass in is ‑‑info. This provides some useful information if you're trying to troubleshoot your environment because what ‑‑info will do, if I scroll up a little bit, it will tell me what version of the .NET SDK I'm using. In this case, I'm using version 2.1. It will also tell me about my runtime environment. Yes, I'm on Windows 10, a 64‑bit version of Windows 10 running on a 64‑bit processor. And the version of the .NET runtime that I'm using is version 2.2.1. So yes, the version of the SDK and the version of the runtime will be different because the SDK version is the version of the tools that I'm using to target .NET for development, whereas the runtime version is the version of this runtime and framework, this library that I'm using to execute my .NET programs. And down here I can see the versions of all the SDKs that I have installed on this machine and their location, as well as all the .NET runtimes that I have installed, so 2.1.0 all the way up to 2.2.1. Let's try a different option that will tell us a little more about what .NET can do. I'm going to pass in a ‑h for the help or documentation for this tool. I can also pass in ‑‑help. And this will tell me the different SDK commands that are available with .NET. So, for example, if I wanted to build a project, I could type the command dotnet build. We're going to see how to build a project in this module because a build is something I have to do when I have C# code inside of a file and I want to run that C# code and execute it as a program. First, I will have to build that source code into another file that the .NET runtime can load and execute on my machine. So dotnet build is one command. You can see a number of other commands here. Here's dotnet test. In this course, I'm going to show you how to write a unit test for your C# code. Unit tests are invaluable for writing code to ensure that your C# code is working as expected. They're also an invaluable tool for a beginner because creating a unit test project allows you to experiment with C# code. You can experiment and figure out how things work with unit tests, and that's something I highly encourage. There's also a command I can execute, dotnet new, to create a new .NET project or file. So let's back up a step and talk about a project. What is a project? A simple description of a project is that it is a collection of source code files that you want to put together into a single application or a single library that you write to share your code with other developers. So before I can create an application, I first have to create a project with some source code for the application. And to do that, I'm going to execute the command dotnet new. This is going to come back with some additional information that I'm required to pass into dotnet new. Let's talk about this in the next clip.

Creating the First C# Project
At the end of the last clip, I had gone out to the command prompt and typed the command dotnet new, and dotnet new came back and essentially said, what is the template that you want to create this new project? So a template is something that I can use to stamp out the basic structure of a new project for an application with the .NET CLI. And all I need to do is specify which template that I want to use, so if I want to create an application that I can run here in the command prompt, then in .NET that type of application is known as a console application. It runs here in the console, which is just another word for this textual environment that we call the command prompt, and on other systems it's known as the terminal or the shell. So if I want to create a console application that will run here on the command prompt, I can type dotnet new console. On the other hand, if I wanted to create a project full of unit tests, I could type dotnet new mstest. I could also create a new web application using a template for ASP.NET Core, that's a web programming framework built on top of .NET Core, and in that case I could type dotnet new web. So in each of these cases, what dotnet new will do is create the basic project structure that I need for the type of application I'm building, whether it's a console application or a unit test or a web application. What we want is a console application. So I'm going to come back to the command prompt and clear everything out. Now we're going to create a new directory where I can create my application. So in Windows, I can type mkdir, for make a directory, that also works on other operating systems. And I want to create a directory called gradebook because as I mentioned in the introduction to this course, we're going to build an application that will store the grades for students in a class. So let me use the cd command to change directory into the gradebook directory. I can see this directory is completely empty, and I could create my project here, but I'm going to make just a couple more directories inside of the gradebook directory. So I'm going to make a directory called src, which is short as a convention for source. This is where I'm going to keep my source code, and I'm also going to make a directory called test, and that's where I'm going to place my unit test code. Now we're not going to write a unit test yet in this first module, but we are going to create the basic console application inside of the src folder, so let me change directory again into the src folder, and it's inside of here where I'm going to create another directory named GradeBook, and I'll do that with some capital letters. So it's inside of this folder where I want the project for my main application, and the name of that application is going to be GradeBook. Let's change directory into GradeBook. In really large projects, you can have dozens of directories inside of the src folder, and each of the directories inside of here can represent a project that is part of a system. It could be an individual application or it could just be a component that is part of a larger application. We're going to build a relatively simple system that consists of just this application project and a unit testing project, but I'm trying to show you a conventional directory structure that you will see for .NET Core projects and .NET Core solutions. So it's here inside of gradebook\src\GradeBook where I will use the dotnet new command to say that I want to create a new console application. So I type dotnet new console, I press Enter, I'm going to see a number of logging messages scroll by, and I should now have in this folder a number of files. So, I'll tell you right now that GradeBook.csproj, the csproj extension means this is a C# project. So this .csproj file can contain information about my application, about my project. I also have a Program.cs. This file is going to contain some C# source code that is already a part of my console application. We're going to look at it in just a minute, but before we look at any of the code, I just want to run the command dotnet run. Now if I press Enter, what dotnet run is going to do, since I haven't given dotnet run any other information, is going to look inside of the folder that I'm currently in for a project, and it will find GradeBook.csproj. And what dotnet run will do is say, oh, you must want to run this project. So let me try to take all the steps that are necessary to execute the code that is part of this project, and we can see the result of dotnet run on this brand‑new console application is to say Hello World! So now that I have my first project and I know this project works because it creates the expected output, which is Hello World, now let's talk a little more about a couple different topics here. Number one, how can I edit this project and make changes to this application that I've already built? How could I make it say Hello Scott, for example. And I also want to talk a little bit about what's happening behind the scenes when I do a dotnet run.

Editing C# Code with Visual Studio Code
I want to change my application, so let's start our editor, Visual Studio Code. From the command prompt, what I want to do is back up a couple of directories, so ..\ to move up one directory, and then I want to move up one additional directory, so another ..\, and that should put me in my gradebook top‑level folder for this system, for this application. And it's from here where I want to launch my editor, so I'm going to use Visual Studio Code, but you can use Visual Studio on Windows, or you can use Atom or Sublime, or really any editor. I'm going to use Visual Studio Code, so I'm going to type the command code, and then period. When you install Visual Studio Code, you're given the option to add code to your path that allows you to type the command code from anywhere on the file system to launch Visual Studio Code, so that's what I'm going to do here, launch Visual Studio Code and tell it to start in this current directory, that's what the dot means. Start by opening this gradebook folder. If for some reason you do not have Visual Studio in your path, then go ahead to your Start menu or your app organizer and start Visual Studio Code, and then just go to the File menu and say that you want to open a folder and browse to that top‑level gradebook folder. So don't go into the src folder where the .csproj file exists, go to the top‑level folder. What I want to see over here on the left in what we call the Explorer window is a complete view of the file system, including the src folder and the test folder. Now, over here on the right‑hand side, the bottom right, there was an alert that appeared for just a moment. I'm going to reopen that alert by clicking on the notification icon here at the bottom. And this notification says that required assets to build and debug are missing from the gradebook. Do I want to add them? Now, if this is your first time using Visual Studio Code, you will probably not see this notification. What you need to do is first install an extension that I used to work with C# source code, and then moving forward, working with C# will be a lot easier. So inside of Visual Studio Code, what you should do is go to the Extensions tab. You can also get there by pressing the shortcut key Ctrl+Shift+X on Windows. And what you want to do is search for the C# extension. So I can just search for C#. There will be an Install button for me to click on, and once that extension is installed, I can restart Visual Studio Code. My extension will be installed, and the next time I start Visual Studio Code with the gradebook folder open, I should have this prompt that assets to build and debug are missing from gradebook. I'm going to click Yes, I do want to add them. This is just going to make it easier to run and debug my applications from here inside of Visual Studio Code and just never leave Visual Studio Code. We'll see how to do that. Once I've done that, I'm going to come back to the Explorer view, which shows me the file system, including Program.cs, which is currently open. If not, I can click to open Program.cs, and it's pretty clear where the text Hello World is coming from when I run this application. Now, as we work through the course, I'll explain some of these other identifiers and keywords that you see in this file, but for right now I just want to say that this sequence of characters that is inside of the double quotes is what we call a string in C#. There's strings in lots of programming languages, so perhaps you're already familiar with strings, but I just want to delete the word World and replace it with Scott, but feel free to use your own name inside of the program. Then I'm going to save Program.cs, and then I'm going to come back to my command prompt, and once again I'm going to type dotnet run because I want to run my project. But now, since I am not in the same folder as my .csproj file, dotnet run is going to give me an error and say sorry, I couldn't find a project to run. Make sure there's a project that exists in this folder or pass a path to me about where I can find the project with ‑‑project. So I can either change directory into the src\GradeBook folder, or I can say dotnet run ‑‑projec. Inside the src folder you will find GradeBook, and look in there for a csproj file, and now my project runs and it says, Hello Scott! So this is a good start. We've already seen how to use the .NET CLI, and we've seen how to use Visual Studio Code to edit C# code, and we've seen how to run and test an application directly here from the command prompt. So now let's start working with some additional changes to our application. But before I do that, I do just want to talk a little bit about what's happening. What is the magic behind dotnet run? What is happening behind the scenes? Let's talk about that next.

Running and Building Your Project
I just want to take a moment to explain a few of the things that are happening behind the scenes when I do a dotnet run. First of all, I'm going to switch back into the GradeBook folder where my csproj file exists so I don't have to pass the ‑‑project parameter to all the commands I went to execute, because it's from here where I can just type dotnet run, and run will find that csproj file. It says, ah, here's the project that you want to run, and it ultimately executes the code that I've described in my C# src code file. But there's a few things that need to be in place before my application can execute. The first thing that really happens behind the scenes implicitly when I do a dotnet run is what's known as a dotnet restore. So in the world of .NET, there is a package system known as NuGet. A package system allows my application to take advantage of features and functionality that are in other bits of code that other developers have written, and these bits of code live inside of files known as NuGet packages. So yes, the library that .NET Core provides has a lot of features, features that allow me to open files and do cryptography and talk over the network, but it doesn't cover everything that I could possibly want inside of a .NET application. So other developers, including Microsoft, will place code inside of NuGet packages and make these packages available from what's known as a package feed somewhere on the internet. Whatever my application needs a feature that is in a NuGet package, I can tell .NET Core that I need such and such a package. That fact is going to be recorded in my csproj file. So what dotnet restore is doing is looking through my csproj file to see if I have any of these external dependencies. And yes, many major programming language environments have this package functionality. So in the world of Node, there is npm. In the world of Python, there as pip and so forth. We don't have any packages referenced from our csproj file, but as we move through the course, we're going to see how to work with NuGet packages because they are an essential part of development. Now, once the restore is complete, what a dotnet run can do, again, implicitly behind the scenes, is a dotnet build. The restore has to happen first because I need to grab all these other dependencies, these little bits of code that are in NuGet packages. I have to grab those so that when I execute a dotnet build, dotnet build can see the full picture of my application. The primary job of dotnet build is to compile my source code. Perhaps you've heard of this term compile or compiler before. The C# compiler that is running behind the scenes as a tool, it can analyze my C# source code and transform or translate that source code into an efficient binary format that is faster to execute when I need to run my application So the C# compiler can come along, look at all of the C# source code that is in my project, all of the .cs that I have on the file system, and take all of that code and produce a single output file that is a binary representation of my source code. So it's binary format, it's not something that I would ever want to open and read, but it is an efficient format when I need to run the application and actually have instructions execute on my computer. The file that dotnet build produces is this file GradeBook.dll. Now, if you've worked with Windows for any length of time, you might recognize the .dll extension as something meaning Dynamic Link Library. But don't think of it that way in .NET Core. In .NET Core, this is what we call an assembly. An assembly is the output of the C# compiler or the VB compiler or whatever language that you're using. It's the output of dotnet build. It contains my code in binary format inside of that file. And you'll notice it's in a folder called bin. Bin is short for binary. It's in, furthermore, a Debug folder, which just means this is a debug build of my application. It's going to be a little easier to debug, and we'll debug this application just a little bit later. And then it's in a folder called netcoreapp2.1 because I have built this using the .NET Core SDK version 2.1. You'll also notice in this GradeBook folder there's another folder named obj. That's short for object or object files, and that folder really just contains some temporary files that are put together during the restore and build process. It's a folder that you can safely delete, and actually, you can delete the bin folder too if you want to. All you need to keep around is your src code and the csproj file. As long as you have those files, you can always do a dotnet build and recreate all these other folders and all these other files. Now, what's interesting about this GradeBook.dll file is that I can go out in Windows and try to execute that file. So let's go into the bin folder, Debug folder, netcoreapp2.1, and then go to GradeBook.dll and press Enter, and my file, my program tries to execute, but it has this error message. Could not load file or assembly System.Runtime. The way to think of this is that GradeBook.dll could not find a runtime that it requires to execute. That runtime is the .NET Core runtime, and that's why if I want to execute GradeBook.dll, I have to go through the .NET CLI, which will provide the proper runtime and launch my application. And there's two ways I can do that from this folder. I could type dotnet run, and what dotnet run will do is make sure it's done a restore, we have a build, and then it will find GradeBook.dll and load it. Or I can use this dotnet command and go directly to GradeBook.dll. So if I go into bin, Debug, and netcoreapp2.1 and then pass the parameter GradeBook.dll, this is a way of saying I want to run something using .NET Core. Please go to this assembly, GradeBook.dll and execute the code inside. And there you can see I get Hello Scott! And this command is something that you'll find across a variety of different programming environments. So when I want to run a Node program, I say node and then some .js file. In that case, no, there's no compiler. I'm executing directly from the source code, but languages like C# and Java that are both compiled, well, with Java, the way I would launch my application is to say java, space, and then the name of a JAR file that contains compiled code. So .NET very similar to Java if you come from a Java background. And hopefully this section just demystifies a little bit some of the files and some of the things that are going on inside of .NET Core and with the C# language that you might see. But now what I want to do is come back to the editor and look at adding some features to our application.

Saying Hello with C#
Here's what I want my application to do before we leave this module. I want the ability to pass my name as a parameter to my application so I don't always have the application saying Hello Scott. It could say Hello Scott, or Hello Allen, or Hello Sue, or Hello Jason. I can have this application say whatever I want, as long as I pass that name parameter to my application. How are we going to do that? Well, let's concentrate just on these few lines of code here inside of the file. So first of all, I am inside what's known as a method in C#. This method name is Main. We'll talk about some of these other keywords of the C# language that we're seeing here like static and void, but for right now, I just want you to know that this is a method inside of the curly braces I place the code that I went to execute when this method is invoked or called. And how does this method get called? Well, when I launch a command‑line application, a console application in .NET Core, by convention, what we call the entry point of the application is a method named Main. So in other words, when I type dotnet run or I say dotnet and then GradeBook.dll, what the .NET runtime is looking for is a method named Main, and then it says, oh, this is the entry point for the application. Let's start executing the code that is inside of that method. And the code inside of this method currently says please go to the console and write out the following text, which is Hello Scott. Well, I want this to be parameterized, and that's where the parameter here comes in with C#. So when I'm defining a method, I can then have some parentheses, and inside of the parentheses after the method name, I can have zero or more parameters. Every parameter consists of a type and a name for that parameter. So the name of my parameter is args, a‑r‑g‑s. That's short for arguments. These are the arguments that are being passed to the application. And the type for this parameter, because C# is what we call a strongly typed language, every variable, every method itself has a type. In this case, the type of this parameter is a string array. So these square brackets after the word string tell me that this is an array. So, first of all, what is a string? It's a sequence of characters like Hello Scott. And what is a string array? A string array would be a collection of those strings. So I can have zero or more strings being passed in as args. So any arguments that I type on the command line that I want to pass to this program will arrive in this args parameter. Now, perhaps you've worked with array in other languages. Arrays are a popular data type that you can find in many different languages. And any language that has arrays will typically provide some feature that allows you to access a specific item inside of an array. So someone might pass me three arguments, and how would I access specifically this second element in that array of three arguments? Well, in C#, I would do that by saying arg and then in square brackets 1. So the way I would read this is args sub 1. And it can sometimes be confusing to someone who's new to the C# language. Why is the second element of the array number 1? Well, it's because in C# we have what's called zero‑based indexing. When you index into an array to access a specific item, the first item in that array has an index of 0. The second item has an index of 1 and so forth. So args sub 1 would be the second item. What I expect to do is pass to this program just a single name. A single name has an argument to what I expect is that args sub 0 will contain the name value that I want. So what I want to do is build a string that consists of this greeting, Hello, and then instead of hard coding the name here, I went the ability to place args sub 0 inside of here. So one way to do that is to say let's take the string Hello and a space and then add to it args sub 0. So now it can be Hello Scott or Hello Alan, whatever I want, and then add an exclamation point. So what I'm doing here is known as string concatenation. I'm building a string out of three smaller string pieces. Take the string Hello. Concatenate onto the end of it args sub 0. That will also be a string because I'm dealing with an array of string, and I'm accessing a single individual string inside of that array here. And then take the single character that I place into a string, the exclamation point, and tack that onto the end. Another way to do this in C#, something that can be a little bit easier on the eyes, is to use a feature known as string interpolation. With string interpolation, what I do is I place a dollar sign in front of the opening double quote for my string. And now what I can do, instead of using this string concatenation, which forces me to break up the string and use plus signs, math operators, what I can do is have a single long string, and anywhere where I want to place in some value into this string, I can just use curly braces, and this is where I want to place args sub 0. So when I'm doing string interpolation, I can place inside of curly braces what's known as an expression in C#. An expression produces some sort of value. So the expression args sub 0 will produce the value that is the first string in the array of arguments that was passed to my program. So, once again, I should be able to say let's say Hello, comma, and then whatever parameter is passed to me and then an exclamation point. Now what I want to do is save this file, program.cs. Very important to save your file. And let's come back out to the command line and issue a dotnet run command. Now I've changed the source code to my application, and dotnet run is going to realize that the assembly, the GradeBook.dll file that it has produced previously, is out of date for the source code that has just been saved. So dotnet run, when I execute dotnet run, it's going to rebuild my application for me, essentially run the dotnet build command. And also when I run dotnet run, I need to pass along a parameter to my application, so I want to pass along the parameter Scott. Except here's a little tip. If I just say dotnet, space, run, space Scott, Scott becomes a parameter to the .NET CLI, not a parameter for my application. If I'm running a console application with dot net run and I have a parameter that I want to pass to the application, not to the .NET CLI, then I need to place a dash dash on the command line to separate my application parameters from the .NET parameters. So dotnet run ‑‑Scott is saying let's run the current project and pass along a parameter, which is Scott. And if I change this and say dotnet run ‑‑Allen, I can now receive the text Hello, Allen, which is perfect. So my application has a little dynamic feature where it can change the output or the text that's being produced. What happens if I just say dotnet run and do not pass any parameters? In this case, my application is going to have an error because I'm trying to access a parameter or I'm trying to index into an array of parameters, and I'm using an index that doesn't exist. It's outside the bounds of the array. Essentially, the array is empty and has a length of 0. There are no parameters to the program, but yet my program is trying to get to the first element of that array. But there is no first element, so we throw an exception. As you're developing your C# source code, you'll probably run into exceptions as you're learning the language. Let's talk a little bit about how to debug this problem.

Debugging a C# Application
Just to summarize what has happened here, I tried to run the program without passing any arguments, yet my program wants to access the first element in the args array, but if I don't pass any parameters, the args array is going to be empty. One of the responsibilities of a .NET runtime is to make sure that my program doesn't do anything that is obviously wrong. Trying to access a non‑existent element inside of an array is something that is obviously wrong. So the .NET runtime will force my program to throw an exception. An exception represents an error condition. Later in this course, we're going to talk about exceptions in more detail. One of two things can happen when the runtime throws an exception, either my program can handle the exception and say, yes, I expected this error to occur or the exception goes unhandled, in which case, it's going to halt the process or crash my process. The .NET runtime is not going to allow a program to continue executing if there is an unhandled exception, which is good because my program might be in a faulty state. It's operating under some erroneous condition. And if we just let it continue, it could do something terrible, like just format my hard drive, so the program was halted because of an error, and now I need to figure out why. When you're first learning the C# language, it can be very difficult just to stare at lines of code and figure out where a problem is, and that's why a debugger can be useful. A debugger can allow me to execute my program in a controlled environment and inspect the environment as I go along to try to find the source of a problem. So let me show you how to use the debugger. This can be invaluable as you're learning the C# language. So, first of all, I want to look at this error very closely, and I want to especially pay attention when the .NET runtime tells me the line of code where this error occurred. So I can see this is in Program.cs:line 9. So coming back to the editor, this is line 9, and what I want to do here is set a breakpoint on this line. So over here to the left of the line number where the little red dot appears, I want to click to make that dot up here less transparent, and that tells me I have a breakpoint set on this line of code. So now, when I run the program with a debugger attached, any time execution reaches this line of code, line 9 on Program.cs, the debugger is going to pause the program and allow me to inspect the environment, so I can look at things, like the parameters array, I can look at variables, I can see what's defined and what the values are. So let's go ahead and try this. I'm going to click on Debug, and I want to start with debugging. That would be the F5 key if I just wanted to hit a keyboard shortcut. This is going to launch my program, so my program is now executing. I can see some log messages scroll by down here in the DEBUG CONSOLE, and I know I have hit my breakpoint because I now have a yellow background on line 9 of Program.cs. Of course, these colors can change depending on your color scheme, but Code is clearly trying to highlight this line of code as where I have paused execution. And if I know this line of code is throwing an exception, well, one of the first things I should look at is what are the arguments? Because I'm trying to access args sub 0, the first element of that array. And this syntax that is appearing here when I hover over args sub 0 is trying to tell me that args is a string array, and it has a length of 0, and that means trying to access any element in this array is going to cause a problem. Another place to see variable values would be over here on the left‑hand side. Here's a list of all the variables that are in scope and in effect when I hit this line of code, so that's another place where I could see that args is a string array of length 0, so I should not be able to access any elements there, and now I know what's wrong with the program. It was trying to access an element that doesn't exist. What can I do? Well, if I wanted to just go in and start fixing code, I could click up here on this toolbar to stop debugging, so Shift+F5. That also happens from the Debug menu. I can say Stop Debugging. However, as we move throughout this course, we're going to be writing more and more code, and you might have multiple breakpoints inside of a program, and you might want to do things like continue execution. So if I press F+5, the debugger would allow my program to keep running until it hits another breakpoint. I can also step through lines of code. I can step over, and I can step into. That would be the difference between entering a method and just stepping over a method. We'll talk more about that later in the course. But if I wanted to move to the next line of code in this program, I could press F10 to step over, but I can see, oh, I'm not allowed to get to the next line of code. I have an IndexOutOfRangeException, and index was outside the bounds of the array, and actually, the debugger has halted my program where this exception has occurred, which again, is line 9 of Program.cs, so I sort of know what I have to fix. I have to make sure that someone has passed arguments to my program before I try to use those arguments. What my program should be doing is make sure that there is an element in the arguments array before it tries to use it, and a way to do that is to walk out to the arguments and check a property named Length. So every array inside of .NET will have a Length property, and the way I access a property in C# is to use the dot operator, is what we call it. So I want to go up to this arguments array and then inspect a Length property, and that's going to give me back a value. A value like 0 would indicate an empty array, a value greater than 0 would say, yes, there is something in this array. So let's write our first simple if‑else statement in C#. I want to use the keyword if, and inside of parentheses, I'm going to use an expression, if args.Length is greater than 0, then, yes, I have something in this array, in which case, I want to execute the next line of code, which is Console.WriteLine, below and then the argument. And in order to place this Console.WriteLine inside of this if statement, so any time it is true, I'm going to wrap that statement with curly brackets. So we'll talk in more detail later in the course about if statements and other conditional statements, but I need to say if and then have some Boolean expression that returns true or false. If this expression returns true, I execute what is inside of the curly braces here, and I can also optionally have an else. So what that if statement returned false? What if Length is not greater than 0? In that case, let's do a console.writeLine and just give a generic Hello greeting. And now, to see if my program works, let me go back to the Debug menu, or press F5, or even Ctrl+ to say, let's just execute this program. I don't need to the debugger. And down here in the DEBUG CONSOLE, I can see the output Hello, which is perfect. Now my program doesn't crash when someone doesn't pass it parameters. But the question is, how do I pass this program parameters now? Well, from the command line, it's very easy. Now, I should be able to say dotnet run and pass in the command‑line parameter Allen, and I get back Hello, Allen!, which is perfect. And if I pass in Scott, I get Hello, Scott! And if I don't pass any parameters, I just get a Hello, so my program is working well. But when I run with the debugger, how do I pass in those parameters? Well, you might remember earlier in this model when I received the notification in Visual Studio Code that required assets were not present to build and debug this project, do I want to add them, and I clicked Yes, there were a few important files that were added to the file system. So coming back to the EXPLORER view here in Visual Studio Code, the files that I went to look at were created instead of a new folder with a .vscode name. So I went to open up that folder, and I can see there's two JSON files inside, and these JSON files control what Visual Studio Code will do when I went to do something like debug or build my project. Let me open up launch.json, and there's a lot of information inside of here that we don't care about. I just want to call your attention to, in this configurations section, this arguments array. So these are literally the arguments that the debugger will pass to my application when it launches it under the debugger or even when I launch the program without the debugger. So in other words, let's pass Scott inside of here and, let me press Ctrl+F5 to run the application without the debugger, and I should be able to get Hello, Scott! out when I run without the debugger. But now, let's try something else interesting. Let's actually pass two arguments, Scott and Allen. This would be from the command line, like saying, ‑‑Scott and Allen. But in this case, I'm going to do this with the debugger, and I want to do this, and I went to press F5 to run with the debugger, and I'm doing that just because I want to show you what the args will look like when you do have a parameter. Now, when I mouse over this, I can see args sub 0 as Scott and args sub 1 as Allen. So yes, these arguments will have a Length. If I hover over Length, I can see the Length is 2, and that means I can use args sub 0 and args sub 1 legally without getting an exception. So this is the type of information that you can look at with a debugger. It can be extremely helpful when you're trying to figure out why your program is not behaving the way you expected. Is there some value in an array that you expected to be there that isn't there? Those are the types of things that you can look at with the debugger, and I encourage you to explore and experiment with this debugging tool before you move into the next module.

Summary
In this first module, we installed .NET Core and VS Code, and now we are writing our first C# program. We also found the first bug in our software. Now, you could argue that the first version of our program requires a parameter from the command line, so it wasn't our fault that the program crashed when me, the user, didn't enter a command line parameter. But we really should write our software to handle bad user input because since the beginning of time, users have given bad input to software, and they'll continue to do so until the end of time. So write your software to be careful with user input. Now, in the next module, we're going to build on what we've learned here, and we're going to start learning the fundamental features of the C# language, and we're going to start by learning about classes and objects.

Learning the C# Syntax
Introduction
Hi, this is Scott, and in this module, we are going to start learning some of the basic syntax for the C# language. There's a lot of information in this module, but we'll revisit some of the topics in this module time and time again as we move through the course. So open up your editor and follow along because I want to give you some small exercises to try as we move through the module. These exercises get you writing code on your own and storing knowledge about C# inside of your brain. Before we start though, let's look at some requirements for our software.

Reviewing Your Assignment
As a software developer, you generally write software to solve a problem for yourself or perhaps for your business. And oftentimes the problem comes to you from a manager or a customer or from an idea that strikes you in the middle of the night. Let's pretend we are working for a school, and the boss comes to us with the following requirements for new software. We need an electronic grade book to read the scores of an individual student and then compute some statistics from the scores. The grades are entered as floating point numbers from 0 to 100, and these statistics should show us the highest grade, the lowest grade, and the average grade. Now one of the biggest challenges you'll face in software development is taking requirements like this and turning them into code. Really, the code itself is easy. It's translating the requirements from your users and customers and coming up with a good system design, those are the hard pieces. But when you're just starting with a language, you need to learn the basic syntax and features of that language so that you don't have to think about syntax details, and you can focus on these bigger, harder challenges. My advice is always to start small. The way to work with software is to tackle little pieces and little problems and get those little things out of the way so you can see the bigger picture. So for these requirements, let's first focus on the part that says given a collection of grades, we need to show the average grade. Averaging a collection of numbers will require some math operations. So let's first figure out how to write mathematical expressions in C# and assign those expressions to variables for storage.

Working with Code Blocks and Statements
Something we learned in the first module of this course is that when we execute or build or run this application, we're going to be executing and running the lines of code that appear inside of this main method, which is the entry point for the application, and I also pointed out that the C# language likes to use curly braces to denote the start and the end of different things in the language. So the start of this method is this opening curly brace, and this method, technically the method body that is inside ends with this closing curly brace, and every start needs an end, that's why it's nice to have an editor like Visual Studio or Visual Studio Code that understands the C# language and can show you when two curly braces match up, either by drawing a line or by doing some highlighting. Now these significant pieces of code that are inside of this method, each of these are what we would call statements in the C# language. So this code on Line 9 is what we would call an if statement. This code on Line 11 is a statement that invokes the WriteLine method on the console. And something you might have already noticed and I haven't talked about is the semicolon that appears at the end of the statement. So some statements in the C# language do not require a semicolon. Obviously, this program is working well without a semicolon at the end of the if statement and in other places the C# compiler, that tool that translates my C# language into an efficient binary format, requires me to place a semicolon at the end of a statement, and the idea is that the semicolon will allow the compiler to figure out where one statement ends and the next statement begins. And the rules about semicolons can be a little bit intimidating when you first start because you might not know am I supposed to use the semicolon here or not, but don't worry too much because the tools are here to help you. So let's see what happens if I say, oh, I don't think I need a semicolon here on Line 11. Let me remove the semicolon and I think I do need a semicolon here on Line 9 after the if statement. Well, if I do that and I save Program.cs, at this point, I would not be able to build or run my program. There are going to be compiler errors, and the C# compiler is going to complain that there is something syntactically wrong with my program. Let's take a look at those problems. I could do a dotnet build from the command line. I can also try to do a Start Without Debugging that's going to do a dotnet build behind the scenes and I can see that errors exist. Let me click on the button to show errors. They're going to appear here in the bottom window of VS Code under the Problems tab. Now this is another area where things could be a little bit frustrating trying to figure out what is syntactically wrong with the C# program. So the first obstacle you might face is that sometimes the problems that are listed in Visual Studio Code aren't problems that you can easily get to inside of your C# source code. So, for example, this says there is a problem where a semicolon is expected. If I click on that line, I'm going to get an error that I'm unable to open Program.cs. Now it's possible this behavior might change in future versions of Visual Studio Code, but in general, if you see problems that are listed inside of the csproj file, the project file, don't click on those problems. Instead, look for problems that are listed inside of .cs files, so Program.cs. And here is another point of frustration that you might have. If I click on this first problem, which is ;expected, it's telling me that this error occurs on Line 12, but here is a little tip, you should really try to work through the problems in your source code starting at the top of a file and working to the bottom because quite often you can have an error at the beginning of a file that is creating another error later in the file, and if you try to tackle that later error, you're going to go crazy and pull your hair out because in many cases what you have is not really an error, it's an error that's caused because of a previous problem. So the situation we have here is actually a pretty good example. There is another problem that is occurring on Line 9, this is not an error, it's a warning, and up here, I also want to point out in the editor I receive little red squigglies when there is an error detected at that location, and I receive little green squigglies when there is a warning at that location and what I want to do is start on Line 9 because that's the first place inside of this file that indicates there might be a problem. And here is the problem on Line 9. The C# compiler is smart enough to say you probably don't want to have a semicolon in this location. You've possibly made a mistake by giving me an empty statement. Now what the C# compiler is trying to point out is that when you have an if statement, the C# compiler is trying to figure out what code do I execute when the expression inside the if statement returns true. Well, without the semicolon here, the C# compiler can easily see that there is a block of code that comes after the if statement, and again, this is the start of that block, and this is the end of that block, and inside of that block right now is a single statement, but this is the code that should execute this block of code, the entire block of code. So even if I have multiple Console.WriteLine statements inside of here, all the code inside of that block will execute. The C# compiler can easily see that, but if I have a semicolon at this location, technically what I'm trying to tell the C# compiler is that if this expression returns true, execute the statement that happens between that if statement and the semicolon, so code that would appear here, but there is no code there. There is no statement there, so I have an empty statement. Now the C# compiler is trying to tell me that you probably don't want to check this condition and then execute nothing, you probably want to check this condition and execute the following statement or block of code that you have here, so get rid of the semicolon that appears there. That is a mistake. Now you'll notice as soon as I remove that semicolon, a couple of things changed in my problem list, and in fact, my red squiggly moved from being on Line 12 to being up here on Line 11 and the problem on Line 11 is that a semicolon is expected. So I do need to have a semicolon at the end of line 11, and you'll notice this entire time there really was no problem on Line 12. The problem on Line 12 was that my syntax had some issues higher up in the source code file. So we just fixed two compiler errors in the program, and everything is back into a state where I should be able to run the program and see hello world or hello Scott, whatever I pass as a parameter. Now another type of statement that you can have is what we call a variable declaration. So we know from our requirements that ultimately we're going to need to work with floating point numbers so that is numbers that have some value after the decimal point. And in the C# language, there is some built‑in data types that I can use to hold floating point numbers in a variable So in a statement where I declare a variable, I'm declaring a storage location to hold some value, and just like this parameter here on the main method, every variable declaration consists of a name for a variable and a type. So if I want to declare a variable X to hold a floating point value, I also have to give this variable a type and the type float in C# can hold a floating point number. There is also a double type in the C# language, this holds a double precision floating point number. So this double type is twice as precise as the float type that I had typed in earlier, it also takes up more storage space, but that's okay. If we want to be as precise as we can, we'll use this double type, and right now I can see a warning. If I hover over the little green squiggly, I can see that access declared, but never used that's simply the C# compiler telling me, are you sure you really need this X? You're not doing anything with it, so let's try to do something with X. One thing I can do with X is assign a value to it. So I can say that X = 34.1, that's a floating point value, or I could just say X = 34, that's an integer value. And I just want to point out that if I were to declare X as an integer, so only hold values that don't use numbers after the decimal point, then I cannot assign the value 34.1 to the integer value because the C# compiler just refuses to automatically convert a number that is of type double to an integer because it's going to lose some information. So let's go back to declaring X as a double and I just want to show you that another thing I can do is just have this initialization expression immediately after I declare the variable, so double X = 34.1. Now what I'd like you to try is to define to floating point variables X and Y, and then add those two variables together to place into a result, then I want you to write the result. So add two floating point numbers and write the result and, by the way, how do you add numbers? Well, the basic mathematical operators in the C# language are addition, which is the plus sign, so I can say X + 2.1, and I can assign that to another variable by saying some variable = X + 2.1. There is also subtraction with the minus sign, multiplication with an asterisk, and division with a slash. So I want you to try to add two numbers together and WriteLine the result.

Adding Numbers and Creating Arrays
Let's do some addition. What I want to do is add another floating point variable to the program. Let's name it y and set that equal to 10.3. And then I want to add x and y and place that into a result. But before I do that, let me introduce you to another feature of C# and a new keyword known as the var keyword. So any time you have an initialization expression like 34.1 and you're assigning that value to a variable at the same time you're declaring the variable, you can take advantage of a feature and C# known as implicit typing. And you can do this with the var keyword. Essentially, what you're telling the C# compiler is that I know you can figure out the type of this variable based on the context and what's happening in the code. I know you'll be able to figure out that x is a double. And indeed, if I hover over x with the mouse, I can see it really is being treated as a double. But the benefit here is that I don't need to provide an explicit type every time I create a variable. Now some people love the var keyword because they think it keeps the code clean and simple. Other people do not like the var keyword. They want to see explicit types everywhere through the program so they don't have to guess what the type is. So feel free to use the var keyword or not use the var keyword. I prefer the var keyword myself, so I'm going to be using it a lot during the course. But I do just want you to know that this is still a strongly typed variable. So this is not like the var keyword in JavaScript where I can go on to say on the next line of code that y = a string. That's going to be illegal because I cannot assign a value of type string into a variable that can only hold a double, a floating point number. So that's illegal. Another place I could use the var keyword is when I define a result. But in order for the var keyword to work, I have to have some initialization expression. I have to say that result equals something. Otherwise, when the C# compiler looks at this line of code, there's not enough information to tell the compiler what is result. So that's the first error that you see in the pop‑up window. Implicitly typed variables must be initialized. When you're using the var keyword, you're allowing an implicit type for that variable. But if I say result = x + y and then a semicolon, now the C# compiler knows that result is going to need to be a double because we're adding two doubles together. So obviously the result has to be placed into a double. If I were to try to place that into an integer, that will be an error because an integer doesn't have enough precision to hold a floating point value. If I tried to place it into a string, that's an obvious type mismatch is what we would call that, trying to put a number into a sequence of characters. So I'm going to leave this implicitly typed as a double using the var keyword. And then what I want to do is a Console.WriteLine and display the result. So here's a little quick tip in Visual Studio Code. Visual Studio Code does include some code snippets for common expressions and common statements that you write in the C# language. So one way I could do a ConsoleWriteLine is to type out Console.WriteLine. But another way to add a Console.WriteLine statement is to type just cw. And I can see in this pop‑up window that cw is going to be short for Console.WriteLine. And in order to expand the snippet, what I do is just press the Tab key, and I now have a Console.WriteLine, and we're using the full namespace to get to the console, which I don't like. I would prefer just Console.WriteLine. And now what does WriteLine actually take? Does WriteLine require a string like the string that we're passing down here? Well no, it turns out that WriteLine can take any number of parameters of any type, and we can pass in integers and floating point values and strings, and we'll talk about how that works a little later in the course. But right now, I just want to say result, and this should print out our result. Let's test it real quick. I want to start without bugging. I'm going to watch the output scroll by down here in the debug console, and I see the result, 44.4 and Hello, Scott! That looks correct. Now if we look back at our requirements, we know we're going to have to do an averaging of numbers. But according to the requirements, we really don't know if there's going to be 1 grade or 10 grades or 1,000 grades or 0 grades. No one said your students will produce exactly 10 grades. So we're going to have to have some sort of collection of floating point numbers that we can manage and that can grow as we add more grades. Obviously, we don't want to do that by declaring a variable for each grade because we don't know how many grades there's going to be. And that's where we can turn to a collection like an array. The parameter that is passed to this Main method is an array of string. It's named args. If I wanted to declare an array of floating point numbers, I could use that same syntax, which is double, and then square brackets and call this variable numbers. And once I do that, I could walk up to numbers, and I could try to read values out of numbers by going to numbers sub 0. Just like down here, we have an expression that goes to args sub 0 to get the first string in the args array. Numbers sub 0 would be the first element in the numbers array, so the first floating point number. And I could also assign a value to that position. So if I wanted to write into the first position there, I could say that number sub 0 equals 12.7. As you can see though, I currently have an error. And if I hover over the red squiggly, I will see that I'm using an unassigned local variable, numbers. So the C# compiler is not going to allow you to use an unassigned local variable because that typically leads to errors inside of a program. You're doing something with this variable that you've never assigned to. In this case, that array doesn't actually exist. All you have is a variable that is pointing to an array that doesn't exist, and we'll talk a little more about pointers and references later in the course. The same is true with explicitly typed variables, by the way. So if I just say double x, so I know x is of type double, but then I try to use double in some sort of expression, like x = x + 3.1, that is also going to be a compiler error because I haven't assigned a value into x. So I need to initialize variables one way or another. And the way to initialize an array if I don't already have an array available is to create a new array to assign to this variable. And I do that with the new keyword. So you can think of this as creating a new array, instantiating an array, and I have to use an expression that says this is going to be an array of double, and I also have to provide a number inside of the square brackets that represents the size of that array. So this syntax where I just have double and square brackets, that's fine for declaring a variable and for defining a parameter. I'm just saying, yes, this is going to be an array. I don't know the explicit size of that array, and that's okay. But down here when I'm creating an array, I have to provide an explicit size. How large is this going to be? How many numbers is it going to hold? Let's use the value 3. So our array can now hold three floating point numbers. And once I have this full initialization expression here on the right‑hand side, once again, I can use implicit typing to simplify these lines of code. And now what I'd like you to do is add two more numbers into the array, so there are three floating point numbers inside, and then compute the sum of those three numbers and write out the result. In the next clip then, I want to introduce you to some new syntax that will hopefully make those tasks easier.

Looping through Arrays
Let's finish populating the array. So I'm going to add numbers sub 1. Let's make that a 10.3 again. And numbers sub 2 equals 6.11. And now one way I could add the result is to say result = numbers sub 0, and then on the next line I could save result = result + numbers sub 1. And then, of course, I could say result = results + numbers sub 2, and then we could Console.WriteLine our result. Let's do a quick run to see if we get the right answer. So I'm going to save Program.cs, start without the debugger, and down here in the output window I can see 29.11, which seems like that's an answer that's in the right ballpark at least. So now let me show you a few things that can simplify this code. Let's start with the array initialization. If I know exactly what values are going to go into this array, so I know there's going to be a 12.7 and a 10.3 and a 6.11, I don't have to write these statements on separate lines like this. Instead, in C#, I can use what's known as the array initialization syntax to go ahead and tell the C# compiler please put inside here the values 12.7, 10.3, and 6.11. So the syntax is simply using curly braces to denote a series of expressions that are separated by commas to say I want a new array that can hold three numbers, and by the way, here are the three numbers. And notice if I try to add a fourth number into the array, I'm going to receive a compiler error. Sorry, you declared an array of size 3, but you're trying to put four numbers inside. So one solution to that problem is that when I know exactly what I'm putting into the array, I can once again rely on the C# compiler to do the right thing. So instead of saying that I want a new array of double that can hold three items, since I now have an initialization expression, I can leave the number out of the square brackets so I don't have to provide an explicit size. Instead, the C# compiler will figure out what size I need to hold these values. And now I don't need to write these three lines of code. So perhaps this code is a little bit easier to understand. Either one will work, but I want to use the code that is the most readable. Now, once I have this initialization expression, it turns out I also don't need to explicitly tell the C# compiler that this is going to be an array of double. The C# compiler can both figure out the type, the underlying type of the array, and the size of the array. So I can remove the keyword double here and just basically tell the C# compiler, look, I want a new array, here's the values it's going to hold, and the C# compiler is going to figure out the rest. If I hover over numbers, I can see, yes, it's an array of double. So these are just little nice things that the C# compiler can help you with. You don't have to write so much code and be explicit about everything. So here's another shortcut by the C# language. Any time I want to take a variable and add a value to that variable and store the result back into that variable, there's a shortcut expression I can use. So instead of saying result = result + numbers sub 1, I can say result and then use an operator known as the += operator to say basically add numbers sub 1 and store the result back into this variable. So the line of code I had there previously and this line of code, they will do the exact same thing. And I can do that also down here. I can say result += numbers sub 2. And now that I've added an additional number into the array, I'm not computing the correct result. And obviously, it's going to be impossible to write code like this where I address each member of the array individually, numbers sub 0, numbers sub 1, numbers sub 2. That code is going to be impossible to write if I do not know the size of the array when I'm writing the code. And that would be the case with an array parameter like args here. I don't know how many args are in that string array when I'm writing this code. Yes, I can check this Length property at runtime to find out how many elements there are, but writing code like this is impossible. And this code also contains a lot of duplication. Essentially, what I want to do is add in a number to my result for each number that is in that array. And when I say for each, that's important because there's a number of looping statements that you can use in C# to loop over and visit each item in a collection. Later in the course, we'll talk about more of the looping constructs and looping statements that are available, but for right now, I want to show you that if you want to do something for each number in the numbers array, you can write what's known as a foreach statement. So let's back out a few of the things we've done. I just want to say result equals, and let's say 0.0. And now, instead of explicitly adding these numbers, I want to write a foreach statement. So the foreach statement consists, first of all, of the foreach keyword, and then inside of parentheses I am first of all going to declare a variable that will hold the value of each item that is in the collection that I am iterating over. And I tell foreach that I want this variable to work across the values that are in numbers. So I'm saying foreach double number in numbers. Behind the scenes, the C# compiler will generate instructions that will visit each number that is in the array, so 12.7, then 10.3, and then 6.11, place that value into this variable, number, and then execute the code that is inside of the foreach statement. How do I place code inside of a foreach statement? Just like how I plays code inside of an if statement. So I use an opening curly brace and a closing curly brace to say foreach number, execute the following code. What I want to do here is add my number into the result. I want you to try that. But before you go, I also want to point out that this value, number, this variable, has to be typed appropriately. So if I try to say pull out each string that you find in the numbers array, the C# compiler is smart enough to say sorry, you're operating on an array of double. You're trying to assign a double to a string, and that's not going to work. So this has to be of type double. That would be explicit typing. But once again, I can use the var keyword to say create a variable called number, give it the appropriate type, and just place each value inside. Now see if you can write the code to still compute the correct result.

Using a List
Inside of our loop, all we need to do is add each number to are result, so that could be an expression like result += number and that will allow us to compute the proper result. Let me run this without the debugger, Ctrl+F5 will do that, and I can see the result is 33.21. And what we've been doing is taking these little steps and what we're working towards is the ability to store grades in a grade book and then compute the average grades. And now we can see how to loop through a collection, how to add up numbers, and I'm sure you'll be able to figure out how to divide one number by another number, but there is one big limitation of the code that we've written. The requirements don't tell us how many grades that we'll need to store. Will there be 1 grade, 10 grades, 1,000 grades, or 0 grades, we don't know. And when we're working with a raise in the C# language, we need to create a raise with a specific size, so I need to create an array with these 4 numbers or I need to initialize an array that can store 10 floating point numbers and that's not going to work well if we don't know how many grades the user might give us. Fortunately, the .NET libraries provide an answer in a namespace System.Collections.Generic. That namespace contains a number of classes that we can use that are data structures, data structures like a stack and a queue, if you've heard of them, and there is also a simple data structure named a list. A list allows me to keep a list of things around, like a list of floating point numbers, and the way I would use a list variable would look like this. Let me use some explicit typing to say that I want a list of floating point numbers. Let's name the variable grades, and before I can use this list type, there are two things I need to do. First of all, when you see this error message that the type or namespace list could not be found, are you missing a using directive or an assembly reference. That is the C# compiler telling you that I don't know what this is. I don't see this type, this class, or this thing that you're trying to use anywhere, and sometimes this is simply because the type that you want to use is in a namespace that the C# compiler is not looking into. So every class in the .NET Framework is going to be in a namespace of some sort. Namespaces help to reduce the collision so that if I write a class called list and you write a class called list and the .NET Framework has a class called list, there is still an easy way to differentiate the three because the three will essentially have different names as long as they're in different namespaces. An example would be this Console class we saw earlier when I used a code snippet that this class is actually named System.Console. System is the namespace that the console type lives inside of, but I don't have to explicitly say system, I can do this, this is legal C# code, but I can remove the system namespace as long as I have a using statement to let the C# compiler know that it should be looking in the system namespace for any types that I use. So now you can use anything inside of system and there are quite a few types inside of the system namespace, but List is not one of those types that is in the system namespace. Now sometimes it's very easy to find the namespace and the tools are going to help you. So if I place my cursor directly on that list where there is a red squiggly and I press Ctrl+. this is bringing up a menu that will help me try to fix this particular error. So the first fix in this list of fixes is to add a using statement to this file for System.Collections.Generic. I want to highlight that entry and I want to press Enter and that is at the top of the file going to add using a System.Collection.Generic because that is where the list type lives. It is technically System.Collections.Generic.List, but I still have an error on this line of code because this type requires one type argument. What is a type argument? Well, there are certain classes and types in the .NET libraries that require you to provide some additional information about how you're going to use that particular type. So, for example, when I want to use a list, in order to use that list, I have to describe what types of things I'm going to put into that list. Are they going to be invoice objects, or employee objects, or integers, or date times, or strings, or double precision floating point numbers? In this case, what I want is a list that will only store double precision floating point numbers and the way I describe that is to use an angle bracket and to put the type double here. So what I'm saying is that I have a variable named grades, and grades will be typed as a list of double. So just like the previous variable is an array of double. This is a list of double, it's just the syntax is a little bit different. And yes, I can also use the var keyword here if I have the right kind of initialization statement. So again, grades, before I can use grades, I need to initialize grades. And once again, I will need to use the new keyword to say I want this variable to point to or refer to a new list of double. Now, yes, the initialization syntax for an array is a little bit different than the way we initialize most of the other types that we use on a day to day basis and what we're seeing here with the new list in the parentheses, this is a syntax and a format you'll become accustomed to, because this is how we use most of the types inside of .NET. The parentheses is almost implied that I'm invoking a method here to create this list of floating point numbers, and in fact, as we're going to see in the next module, that really is what is happening. There is a special method that can create my list of double. And at this point, I can use grades very much like an array with the addition of being able to add things into it. So unlike an array which has a fixed size and it can be difficult to add new things into an array, it's possible, but it's just not very efficient, a list is implemented from the start as this dynamically sizable collection that you could just keep adding and removing things from. So notice when I want to add something to a list, I have to add something that is of type double, which makes sense. So I can say, let's add the value 56.1, and then just like an array, I can also index into a list. So I can say, let's look at the first element in that list. What is it? It's grades subzero just like I would go to an array subzero to look at the first element. So arrays and lists share a lot of the same behaviors and features and it's just that a list is dynamic, I can add new things into it. So up here, let's change this to use implicit typing. I'm just going to say var grades = a new list of double, and in fact, just like with an array, I can provide an initializer if I just want to go ahead and add some values into that list right from the start. So now my list contains the same four numbers as this array, it's just that with this line of code, I'm adding an additional number. So in addition to sharing some of the same initialization format and being able to index into a list, I can also use a foreach statement to iterate or loop over that list. So instead of thing foreach number in numbers, I want to say foreach number in grades, and if I run this program with Ctrl+F5, I will see the result 89.31, which looks about correct. And now what I'd like to see you do is compute an average for all the grades that are now stored in the grades list. Now, when you do that, I don't want you to just take the result and divide it by five and hard code the value five. What I want you to do is figure out how to find the number of items that are in this list. Just like an array has a Length property, a list has a property that will tell you how many things are stored in the list, it's just that that property is not called length. Let's see if you can use the tools or the documentation or the IntelliSense that pops up after you press a period to figure out what you can use to compute the average.

Computing and Formatting the Result
Let's compute an average grade, and before I take that step, let me also delete this line of code that is defining a numbers array. We're not using that anymore. We just want to compute the average grade. So at this point, by the time we reach line 18, we now have a total sum of all of the grades. All I need to do is divide by the number of grades to compute the average. So I could say that result equals result divided by, and here's how I find how many things are in the array. If I just scroll through the IntelliSense list here, I can see a count, and if I were to look it up in the documentation, yes, count would say, this is how many items are in this list. And just like with addition, I can also say, /=grades.Count. So divide the result by grades.Count, and then assign that value back into result. At this point, if I run the program again, you can see I get the results 17.862, which sounds roughly correct. And if I wanted to make this a little bit fancier, what I could do is use some string interpolation like we did before to build a more proper descriptive output for the program. So let's say that the average grade is, and again inside of curly braces, which in this case is not describing a block of code or denoting a method body. When I'm doing string interpolation by defining a string that has the dollar sign before the opening double quote, the curly brackets allow me to poke data into the string at the appropriate location by writing simple expressions. If I do a quick test by running this program again, we should have the same result, which is 17.862, but now we're just not spitting a number out of the program; we're actually telling the user that the average grade is, and here's the following number. Now what if I wanted to do some formatting on this? The requirements didn't say this, but typically you're going to have some sort of formatting requirements for your output. So if you're displaying an average, you might want one digit after the decimal place or five digits after the decimal place. It all depends on how much precision your business needs for this particular number. Now I'm not going to give you an exhaustive list of all the different formatting options that you have with the C# language. There are probably two dozen ways to format this number, but I can tell you, if you go to your favorite search engine and search for C# format floating point number, you'll find lots of different examples that ultimately boil down to this. When I want result output in a specific format, I can apply a formatting string that looks something like N3. This is a way of saying that I want this formatted as a number with three digits after the decimal place, Let's try N1, actually. So one digit after the decimal, and now a Ctrl+F5 will give me the result, 17.9. So there's dozens of these little formatting specifiers that you can add, to format numbers, to format dates, to left align and right align strings. There's lots of options, and I'll let you discover some of those on your own.

Summary
In this module, we learned a few of the basics in C#. We learned how to declare variables, we learned how to write statements like looping statements and if statements, we learned a little bit about arrays, we learned a little bit about a list. And now we're already looping through a list of floating point numbers, a list of grades, and we're computing an average grade. In the next module, we want to build on the code that we have and start to build a better abstraction for storing these grades and computing result. We'll do that by defining a class with the C# language.

Working with Classes and Objects
Introduction
Hi, this is Scott, and in this module we reach the point where we are ready to talk about classes in C#, because C# is fundamentally an object‑oriented programming language. And before we can create custom objects that work for us, we have to create a class that defines those objects. So in this module, we are going to learn the C# syntax for defining a class, and we'll also start to explore the fundamentals of what it means to do object‑oriented programming.

Creating a Class
In this module, we're going to define our first class, but you've probably already noticed that our project already has a class defined, and that is the Program class. In C#, a class defines a new type, and a type allows me to do things and get work done. So a string array is a type, and a list of double is a type, and even console is a type. And each of these different types that I'm interacting with have different behaviors, and they store different information. So a list of double is all about having a collection of numbers, a collection of floating point numbers, and I can add new numbers into that list. Console, that type provides methods that I can use to make text appear on the console. So in order to get anything done in the C# language, I typically need to have a type involved. So all of this code that I have to have a collection of numbers and to average those numbers, it's all organized inside of a method, which is in a type. In other languages, you can take code like this and just have it loosely floating around inside of files in any location. But in C#, we just require a little more structure. And in order to write this method to contain this code, I would first need to define a type or a class. Now the question is, why do we need to define a new class? And the answer is, well, I certainly could put all of the code that I need to satisfy our requirements that we looked at in the last module, I could place all of that code here inside of the Main method. In fact, I could have dozens and dozens of lines of code, even hundreds of lines of code, even thousands of lines of code inside of this Main method. And people ask me all the time, how do you know when to create a new class? And I tell people you have to look and see when your software is becoming too complex, when you have a method that has too much code inside of it, when you have a file that has too much code inside of it, that's when you should start thinking about how can I use a new class to provide some encapsulation for the complexity that I'm looking at. Imagine you walk away from this program and you come back 5 months later, and I show you these five or six lines of code right here from line 13 to 18. And I say, tell me what this is doing, and you have to answer instantly. Well if anyone has walked away from this code for 5 months, even me and I look at it, I'd have to start looking at the details of each line of code to see oh, we're looping through a collection of numbers, we're adding all these numbers to a result, we're dividing by the count. Ah, this is computing an average. So just for these five or six lines of code, it takes me a couple seconds to figure out what is the purpose of this code? What is it actually doing? If I were to encapsulate this code inside of a better abstraction, like another method that is part of a class, I might see a line of code like this instead. So I might see something that just says ComputeAverageGrade and passes in the grades, and now let's pretend we're doing the same exercise. Walk away from this code for 5 months, come back, look at line 13, and tell me what it's doing instantly. Oh, I know. It's computing the average grade. That's simple. And that is always what we're trying to do in software development. We're trying to build the right abstraction, have the proper encapsulation, and build the right model to manage software complexity. Because, yes, the requirements that we're looking at for this course and this module are very simple. But real‑world software is never that simple. We have huge systems with millions of lines of code. If we didn't break that code up into methods and into classes, no one would be able to work on that code and get anything done. So that's what we want to do in this module. I want to build a new class that will encapsulate what we're going to write or need inside of the Main method here. And what you'll see in the end is we'll end up with code that is essentially what we have now. It's just going to be reorganized and repositioned to be a little bit easier to work with. And speaking of that code. I'm going to go down here to line 21, and I'm going to delete these lines of code that are saying Hello, name or just Hello because that's really not the purpose of our program. It's just sort of cluttering things up. And this will allow us to focus on our requirements to build a grade book. Now before we move forward, I just want to point out that this is the syntax for defining a class. I used the class keyword, and then everything that is a member of that class or associated with that type will be between the opening curly brace and the closing curly brace. Pretty much every class and every type that you write should be inside of a namespace. If you're not inside of a namespace, you're in the global namespace, and the global namespace is dangerous. We don't know what's in the global namespace. It is completely legal for me to get rid of the namespace here, remove this closing curly brace, and this is legal. Program is now in the global namespace. But what's dangerous is someone else might place a Program class into the global namespace, and then I'd have a conflict. I'd have a compiler error. It's much safer to put everything inside of a namespace that you control or that you name. So you're not conflicting with types and classes that are defined by, for example, the Microsoft libraries, which have thousands and thousands of classes. But all of those classes are typically in a namespace that starts with the word System. So just by having a namespace that doesn't start with the name System, I know I'm not going to conflict with any of the built‑in .NET types. And yes, you can have dots in your namespace. So it's quite common to have, let's say, GradeBook.Math, and that namespace will contain perhaps a number of classes that are all related to the math operations for a grade book. But in this case, all we need is just the simple namespace, GradeBook. So every type you interact with from the .NET Framework is going to be in a namespace. So the list type is in the namespace System.Collections.Generic, and the console type is in the namespace System. So, as I pointed out in the last module, you can write System.Console.WriteLine, and then you don't need the using statement. But I prefer to never see namespaces in my code. I always went to collect those namespaces into using statements. It just makes the code a little bit easier to read. So here's our first goal. I want to define a new class, let's call it Book, that is going to represent a grade book. And ultimately, what I want to be able to do is define a variable of type book. Perhaps I name it book, or perhaps I just used the var keyword for implicit typing. So I want to be able to create a new variable and assign it to a new instance of a class named Book. So IntelliSense filled in GradeBook there, but I want a class named Book. So see if you can come up with the basic syntax that will allow this line of code to compile without an error. Currently, we're going to have an error that the compiler cannot find a type named Book.

Adding State and Behavior
We need to define a new class, and based on the syntax I'm seeing here, I'm hoping all I need to do is say, I need a class named Book and then just provide an opening curly brace and a closing curly brace. So Book doesn't have any members. There's nothing associated with it, but this is the minimal amount of syntax I need to make this program compile. So, yes, the C# compiler understands what Book is now, and it can create a new Book that I can interact with. So it's legal to place as many classes as you want inside of a namespace and even inside of a file, but most C# developers follow a convention where we only allow one class per file. In other words, this Program.cs file is dedicated to the Program class. If I'm going to create a new class named Book, I'm not going to put it in the same file as Program. I'm going to create a new file for Book, and I'll name it Book.cs. So let's do that. I'm going to cut that code. I'm going to right‑click on my GradeBook folder, and say that I want a New File, and name it Book.cs. And inside of here, I can paste in that code, but first, I will make sure that my class is going to be inside of a namespace, a namespace named GradeBook, and inside of the namespace I can now paste my class. And any time that I'm writing a new class, I'm thinking about how can this class be the right abstraction for what I need? And building the right abstraction means giving this class the right members so that other developers can understand what it's doing and make sense of things. So what do I mean by adding a member? Well, if we look at the built‑in list type, this can hold a collection of different types of objects. So in this case, we're working with double precision floating point number, so a list of double. So what can this list do? Well, if I look at the IntelliSense window by just walking up to grades and using the dot operator, I can see a number of methods available to me on this list, methods that I can invoke. I can invoke methods to add a new number, to clear this list, to search through the list. I can also get a count of how many things are in the list. That's a property, not a method. A method I always have to invoke by using parentheses. So that's why with grades.Add, I have to use parentheses, and inside of the parentheses I pass a parameter. Here's the number you're going to add, but when I look at Count, that's just a property. I don't need to use parentheses here to invoke a method. I can simply say grades.Count, and that produces a value for me. So one of the things to think about when you're building a new type, a new class is what are the operations or what is the behavior of this particular class? What are the things that it can do so it can find stuff, it can add stuff, it can remove stuff, it can sort stuff? That's one major piece of building an abstraction. And then the other piece is what is the state that is going to be stored inside of instances of this type, this class? Obviously, a list of storing data or what we can call state, and that state is the numbers that I'm giving to the list. So 12.7, and 10.3, and so forth. So a class, you can think of it as consisting of two things. There's the state or the data it holds, and then there's the behavior, which typically acts on that state. The way I want to use a book is I want it to hold the grades that are coming into my application. And then I went to provide behavior that will act on those grades, so behaviors that will allow me to add grades to the book and behaviors that will allow me to compute the statistics for all the grades that the book is holding. Let's look at how to define behavior next.

Defining a Method
What I want to do is start adding behavior to my book. So I want to give people the ability to add a grade into the book, and that means my book will need a method. What I like to do is try to picture the method before I actually try to write the method in the class. So how will people use my book? Well, they might walk out to a variable typed as book and say that they went to add a grade and then pass in some value like 89.1 would be a good grade. Currently, this code does not compile because the book does not have a method named AddGrade. Why don't you pause here and see if you can add one? You can already see the syntax for adding a method definition to a class, so this is the main method. Inside of the Program class, you'll need something similar, something that takes a parameter, but the parameter will be of type double. I just want to caution you that you do not want to use the static keyword. Instead, use the keyword public when you write your method, AddGrade, but just see if you can make the compiler happy. See if you can make the red squiggly go away by creating a method inside a book named AddGrade. And the method doesn't do anything yet, and we are going to come back later in this module and talk about what this static keyword means and what the public keyword means that you're going to need to use. Here's how I'm going to add the method over in Book.cs. Again, I want to use the public keyword and then the void keyword because this method is not going to return a value. We will certainly see methods that return something as we work through this course, but the name of the method is AddGrade and then inside of parentheses is my parameter list. So I want us to take a single parameter of type double, the name of my parameter is going to be grade, so I expect someone to pass me a grade, and inside of here will be the implementation for grade. Somewhere in here I'm going to have to store a grade as a piece of state for an object that's been instantiated from this class. I might also have some validation logic. So typically in a business application, if you take input from a user, you have to validate that input. So I would have to check to make sure that grade is greater than or equal to 0 and less than or equal to 100. I could do that with an if statement or with several if statements. We will come back and add validation logic like that later in the course, but right now I just want to point out that if we come back to Program.cs, we have gotten rid of the compiler error. We now have legal syntax. We've added our first method to the class definition. Next, we'll need to figure out how to store this value as a piece of state inside of the book object.

Defining a Field
There's a number of different ways that you can add state to a class definition. A popular approach is to add what's known as a field definition to your class. A field looks very much like a variable declaration inside of a class. So just like we have a variable declaration for the variable grades, that's going to be of type List of double, is just that I'm using implicit typing here with the bar keyword. I can add a field to my book class named grades that is of type List of double just by using a line of code here outside of any method definition. So if I were to declare a List of double named grades inside of the AddGrade method, this would now be what we call a local variable, so grades would only be available when I'm inside of the AddGrade method, and that's not what I want. I need a piece of state that this object of type book will carry around with it for the rest of its lifetime. So instead of grades only existing when someone calls AddGrade, I need to cut that line of code and place it here inside of the class, but outside of any method, and this is no longer a variable, it is a field, and by the way, with a field you cannot use implicit typing. So even if I said this is a new List of double, I cannot use the var keyword here, I have to say List of double, and of course, List is in a namespace that we currently do not have a using statement for in the CS file; so when you add a using statement to a CS file, it only applies to that one file, I'm just going to hit Ctrl+. and say yes, please bring in a using statement for System.Collections.Generic, and now any methods that I have inside of the book class will have access to this grades field and can interact with that field. So I can say, for example, that I want to add this incoming grade into the list that is maintained by that field. so I'm now storing that piece of state as part of my object, and we're one step closer to finishing our requirement, and hopefully you're starting to see that, yes, we have some of the same code that we already wrote, and it's just rearranged a little bit differently inside of this book class. Now, assuming you've written the same code so far, why don't you go ahead and press Ctrl+F5, or go to the debug menu and try to run with the debugger, and you'll be disappointed to know that there's going to be a catastrophic exception. This exception is the NullReferenceException, and it's a very popular exception in .Net, and it indicates that something is seriously flawed about your program, something is wrong with your logic. The exact error message here is that object reference is not set to an Instance of an object. Let's talk about what that means in the next clip.

Adding a Constructor
When we ran the debugger, the null reference exception, the error that occurred happened here on line 9 of Book.cs. All we're trying to do here is add a grade into the list of grades that we're maintaining, and it's easy to look at that line of code and say, How could it fail? We're doing the same thing inside of Program.cs, and that worked just fine earlier. But what's happening inside of Program.cs and what's happening inside a Book, they're two different things actually. Inside of Program, notice that this local variable, grades, is a variable that we initialized to point to a new list of floating point numbers. So there's an initialization for this variable. Over in Book.cs, we never initialized grades. I never say grades equals anything, and whenever you receive an all reference exception, it's because you're using a field or a variable that has not been properly initialized. Now the solution to this problem is very simple. All I need to do is initialize grades. It's just a little bit of code, but before I do that line of code, I just want to make sure that we're clear on a few terms. I've been using the terms class and object and null, but let's take a step back and try to understand what those really mean. Think of a class like a blueprint. It describes how I'm going to build objects. So better yet, think of the memory inside of your computer like a big pile of cookie dough, and every class that I define is like a different cookie cutter. So if I pick up the Book cookie cutter, and I walk over to my computer memory, that pile of dough, I can stamp out cookies with that cookie cutter. Those cookies are objects and each of those objects that I'm creating with the cookie cutter, they have the same shape. They have the same type. They're all of type Book or Employee or Invoice or whatever class you have used to instantiate that object. That's another word we use for creating an object. We instantiate a class that creates an object, and that's what's happening over here in Program.cs when I say I want a new list of double loading point number, that action is creating a new object of type List<double>, and every list I create, I know I can add numbers to that list. This method is part of the class definition that's going to be there for every list I create. Just like with Book, it doesn't matter how many objects I instantiate by saying new Book, every book I create will have a method named AddGrade. But it's important to understand that every book, every object can have different pieces of state. Take this example for a second. Let me create an explicitly typed variable, which is book2, and say that that is a new Book and say I want to add a grade to book2, and we'll add the value 90.1. So now I have two different objects that I've instantiated using the Book class. Since both of those objects are the same type, I can always invoked the method AddGrade on this two objects where they're going to be tracking different pieces of data, different pieces of state. So this book has the value 89.1 inside, whereas this book will have the value 90.1 inside. When I asked these books later to compute statistics, as long as they have these different values inside, they're going to give me different answers. So they have the same behavior, but every object can carry different and unique pieces of state. So I use classes to create objects. And we would say that this variable, book2, refers to an object in memory of type Book. And this book variable refers to a different object of type Book. Different object, but same type. Now what happens if I do not initialize book2? Well, if I do not initialize book2, I will have a compiler error because the C# compiler can look at this local variable that's defined inside of a method and say, You have never assigned anything to book2. It's uninitialized. That's going to be a definite error. But what happens if I explicitly assign a value known as null? So null is a special value in .NET. There's a keyword here for it in C#, and null is a way of saying that this variable, book2, does not refer to an object. And if I try to interact with the variable or a field that holds the value null, and I try to use the dot operator to do something with that field or with that variable or with that parameter, I'm going to receive a null reference exception, and there's a good chance my program will crash. Now I want to say there are some advanced techniques that you can use to interact with variables that contain the value null. But, in general, if you come across a variable with a null value, you want to avoid trying to use that variable. In fact, there're lots of places that you'll see inside of C# code and regular applications where someone will do a check to say if(book2 == null), well, in that case, we're going to do something different because we cannot use book2. I will also say that nulls can be such a headache, and they've been such a source of errors over the years, that there're some new features being added to the latest version of C# that will help to prevent null reference exceptions and help you to avoid those scenarios where you might interact with something that has a null value. I'll talk about those more later in the course after the new C# features have been released. But, hopefully, now you understand that a class is like a blueprint. I use the class to define objects of a certain type. I used the new keyword to instantiate a class and create those objects. And if I leave around some uninitialized fields, those fields can contain a null value. If I try to use a null value, I get a null reference exception. That's bad. So how do we initialize grades? Well, one easy way to initialize grades is to simply write an initialization expression here that says grades should equal a new object, which is instantiated from the List<double> class. So it's a new list that'll hold double precision floating point numbers. That's one way to do it. I'm going to show you a second approach. So when I use the new keyword, I use the class name here, Book or List<double>, and then I use parentheses, and it's almost like I'm invoking some method named Book or a List<double>. It looks just like AddGrade, except there's no parameter being passed. And that's because, actually, behind the scenes, there is a method being invoked. Behind the scenes, the .NET runtime is invoking a method on my class known as a constructor method. So the idea behind a constructor is that it constructs objects of type Book or of type List. And inside of a constructor method, if I choose to write a constructor method, it's optional, but if I choose to write my own constructor method, I can take complete control over the initialization of an object produced by my class. Let me show you how to write a constructor. We're going to write what's known as an explicit constructor because it's actually going to appear in the class. Otherwise, we would have what's known as an implicit constructor where the C# compiler just provides a constructor for us that does the default initialization. We want to have a constructor that explicitly initializes grades. So I'm going to use the public keyword again because we are writing something that is like a method, but now, instead of using a return type, like void or int or something, I'm not going to have a return type. I'm just going to write a method that has the same name as my class, so Book. And it's a method, so I'm going to end this with parentheses and then use curly braces to denote the body of this constructor method. So a constructor is just another method on your class. But it has some special conventions. It has to have the same name as your class. It cannot have a return type. And inside of here, any code that I write, so if I write something like grades = new List<double>, this code is guaranteed to execute when I use the new keyword against this class, and then I can be sure that it will execute before I invoke a method like AddGrade that will try to use that field. And now let's try to run the program again with the debugger and F5, and now it can go the whole way to the end of the program. I can see the average grade is 17.9. Everything has worked, and we have avoided the null reference exception because we have properly initialized our field named grades.

Requiring Constructor Parameters
Now we know that book is a variable that is going to refer to an object of type book, and any time we have an object of type book, we are guaranteed to have an AddGrade method because that is part of the class definition for a book, so let's add the grade 90.5. We also know that somewhere inside of that book, we have a list of grades. So why couldn't we just walk up to that field named grades and add whatever we want into that? Well, if I try to do that, the code I'm writing has a compiler error, and if I hover over this, I can see book.grades is inaccessible due to its protection level. So what is a protection level? Well, before we talk about that, let's again talk about why are we building a class? We're building a class to provide some abstraction and some encapsulation, were trying to hide some complexity inside of that class. So again, I'm going to go back to the example where if you leave this program for 5 months and come back and look at these 5 or 6 lines of code, what are they doing? You're going to have to look at each line of code and remember oh, yes, we're computing an average, but if this was just a method call on the book, a method called like compute statistics, then at a high level, you would instantly know when you're looking through this main method, you'd instantly know what is happening on that line of code, oh, we're computing the statistics and all of the details and the low‑level calculations, they'll be hidden and abstracted behind a method named calculate statistics. We also call that encapsulation. Encapsulation is hiding complexities and hiding details that are unimportant at a certain level. So certainly, all of the code that we write is going to be important. We would not get the correct results if we didn't care about all of our code, and if all of our code wasn't important. But again, at a certain level like reading through the main method, are the details of how we're computing an average or how we're computing the statistics. Are they important? No, probably not. Just like when I add a grade to the book, if all I want to do is add grades and compute statistics, are the implementation details of AddGrade important? Do I care if that grade is stored in memory, or in a file, or in a database, or if we call something over the network to put that number in cloud storage somewhere? No. At some level of programming, all I care about is that I have a book and I can add grades and I can compute an average, that's a method we'll have to add later, but for right now, whoever wrote this book did not want to give me access to the underlying list of grades. So inside of a class definition, these keywords like public are what we call access modifiers. They control the access to this particular member of the class. There is a few different access modifiers. I'm only going to talk about a couple of those modifiers right now. We'll talk about more access modifiers in the future, but one access modifier is obviously public. Public means towed outside of this class and have access to this particular method, this particular member. I can add this public access modifier to methods, I can also add public to fields. So if I were to make my grades field public, I am granting access to that particular piece of information, that field, the code that lives outside of the Book class. So coming back to Program.cs, notice how the error went away. I am now legally allowed to access the Grades field, but usually this is not what you want. Typically, you'll find in most object‑oriented development we are very protective of our state. We don't want outside code coming in and just modifying some of the data structures that were using to store things like grades. Someone might add a grade that is illegal, and if we're trying to enforce the requirement that all grades are between 0 and 100, well, I just gave the opportunity for someone to stick in a 101, which is an illegal value. And if I forced people to always go through AddGrade, this method to add a grade, then one of the things I can do is add validation logic to make sure that they are passing legal values. The other thing I can do is hide the implementation detail that were actually just storing these grades in an in‑memory list. So I could switch things around in the future and store things to a file or to a database. Now what happens if I remove this access modifier? Well, that's like using a different access modifier, which is the private access modifier. Private is a way of saying, I only want this grades field to be available to code that is inside of this class definition. So, yes, I can legally access that field in my constructor. I can access that field in the Addgrade method, but these are both members of the class, so it's legal for the code here to access the field, but code outside of the book, that code is not going to be able to get to this field. Let's add another field just for fun. Let's imagine that we want to give every book a name, so this could be Scott's book or the Science Class book. If I were to do that, I would probably want to store that piece of state here inside of the class, so I would create a private field and let's call that field name. Now, in order for someone outside of the Book class to be able to give this book a name, I have to provide some mechanism where they can pass a string that I used to set the name of this book. One way to do that would be to add a method. Perhaps the method could be called SetName. Another way to do that is to require a name when you invoke the constructor. So let's add a constructor parameter. When I do this, as we'll see in just a moment, anyone who uses the new keyword and invokes this constructor will have to pass a name, and inside of here, what I want to do is assign this incoming parameter with the name name to my field named name and that creates a bit of a problem because if I just say, name = name, well, it turns out this parameter, since it's the closest thing with the name of name in this code, it's going to hide that field that's further down there, and the C# compiler is basically saying, look, you're making an assignment of the same variable. Name = name makes no sense. It doesn't know that I mean the field name on the left‑hand side and the parameter name on the right‑hand side. So how do I take this value and pass it along to the field? Well, there's a little trick to do that in C#. This is a scenario that could come up commonly, and the trick to do that is to use a keyword named this, so the this keyword, this.name. This is what we call an implicit variable that is always available inside of methods and inside of constructors, and you use it when you want to refer to the object that is currently being operated on. So I'm saying this object, on this object, I want to set the name field to this incoming parameter named name. I can also use this inside of a method so I could say on this object, go to the grades field and add a new grade. So this is implicitly used whenever I'm accessing a member of the class. And that's why most people will leave off this because all it will do is just clutter up code, but there are these special circumstances where you're forced to use this if you want to have a field with the same name as a parameter that's coming in. Now when I construct a book, so over here in Program.cs, I need to pass along a string and let's call this Scott's Grade Book, that piece of state will be stored and encapsulated inside of the book object.

Working with Static Members
So I've been trying to cover every keyword and identifier and symbol that we have seen in our application so far, but there's one keyword that I haven't told you about, and that is this static keyword. What does it mean for a class member like this Main method to be static? Well, first, let me describe what is the opposite of static? The opposite of static is to have a method that does not use the static keyword, and this is what we call an instance member of a class. So AddGrade is an instance member and instance method of the class Book. And that means whenever I have an object of type Book, the AddGrade method will be available. These fields are instance fields that are associated with an object of type Books. So every time I have a Book object, that Book object, you can think of it as containing and encapsulating a list of grades and a name, and those two pieces of state are private to that object. Statics are not associated with an object instance. Static members like this Main method are not associated with an object instance. Static members like this Main method are associated with the type that they are defined inside of. What do I mean by that? Well, let's come down here and temporarily, I want to create a variable named p, and I went to set it equal to a new Program object. So I'm going to instantiate this program class, and I now have an object of type program that I'm referencing through this p variable. And now I want to invoke the Main method. This requires some arguments. Let me just take the arguments that are passed to the Main method and pass them through along to the Main method, but this is going to be a compiler error. The compiler error is that Member Main cannot be accessed with an instance reference; qualify it with a type name instead. That's a roundabout way for the C# compiler to tell you, sorry, but this Main method that you want to invoke, you cannot reach it through an object reference. It is not associated with a specific object. Instead, it is associated with the class named Program. The only way to reach the Main method is to use the class name where Main is defined; that is the type name Program, and yes, this is legal code now. I can say Program.Main, and pass along the args, and now my program would run forever in an infinite loop, because Main calls Main, and actually we wouldn't run forever. Actually, the program would eventually crash, because it just keeps calling this method in an infinite loop. Let's look at this from the other direction, too. So I no longer need these lines of code. And I do just want to point out that I can comment out these lines by putting a // in front, or, and if I want to comment out multiple lines, I can use /* and then where I want the comment to end, I can use */ and now everything in here is still available in the source code, but the C# compiler effectively ignores that. And then another way to do this, if you need to comment out code very quickly, just highlight the lines of code that you want commented out, and then hold down the Ctrl key and press K and then C. That will comment out the highlighted lines. To un‑comment those lines, hold down the Ctrl key and press K and then U. So now those lines of code are un‑commented. What I'm going to do actually is delete those lines, because we're not going to use them. What I want to show you is what about the book? So currently, AddGrade is not a static method, and that means if I walk up to the Book class, the Book type, and try to invoke AddGrade, it's not going to be available. Well, let's try to invoke AddGrade and pass along a 77.5. Now the compiler error tells me an object reference is required for the non‑static field, method, or property AddGrade. So that's the C# compiler telling me, you need an object reference; you cannot access this method just by using the type name. That's only available for things that are static. And although this is not what I want to do, what I could do to fix this problem is come over into the Book, and I could say yes, let's make this a static member of the Book class. And now all of a sudden, Program.cs, this Book.AddGrade, that line will be legal. And, yes, in case you haven't realized it yet, C# is a case‑sensitive language, so this is uppercase B, the class named Book, this is lowercase b, the variable book, and what I have now is an AddGrade method that is static, so it's only available through the type name. It's not available through a variable that is an object reference, and over here inside of Book.cs, it's important to understand the ramifications of adding a static member. AddGrade is no longer associated with an object instance. However, the fields that it wants to use, or at least the Grades field, is still associated with an object instance, And that's a problem because now the only way to make this work and still have a static add great method would be to make the grade field also static. And what does that mean? That means that grades would no longer be contained and encapsulated by an object of type Book. Instead, this list of grades would be associated with the class Book, the class itself, and the problem there is inside of an application, there's only one Book class, so I can only have one list of grades. It won't matter how many times I say new book, the Grades field will not be in those object instances that I create when I say new book. There's only one field for grades, and it's associated with the class. But in the end, all I want to tell you is you have to be very conservative when using the static keyword. Chances are you do not want to use it unless you're in a specific or a special circumstance. In many ways, the static keyword negates the benefits of object‑oriented programming, because anything that a static is not associated with an object. So I'm going to remove all these static members from Book.cs, and come back to Program, and instead of treating AddGrade like a static method, let's go back to the object variable and go ahead and add a third grade into the grade book that we've created, Scott's Grade Book. Now there are places where static members can be useful, and in fact, we're already using some static members inside of our program. Not only is the Main method static, but this WriteLine method on the Console class is also static. So in order to write to the console, I don't need to instantiate an instance of the Console class. Since WriteLine is static, I can just walk up to the class, the System.Console class, and do a .WriteLine. So that makes the WriteLine method very easy to use. Here's another place where static is used. Let's say that we want to find the highest grade in this list. In order to do that, I'm going to need to look at each grade as we loop through the grades, and we're going to have to figure out which one is the highest. And that means we're going to have to keep track of the highest value that we've seen so far. So let's create a variable. I'm going to call it highGrade, and what do I initialize this to? Well, I want to initialize this to a very low value so that as soon as I look at any grade in the grade book, that first grade will be higher than the value I started with. Well, it turns out there is a static member on the double type named MinValue, and this property, double.MinValue, I can reach it without using parentheses, so it's just a property. It provides me with the smallest possible value that you can place into a double precision floating point variable. And that means I'm starting off highGrade at the lowest possible value. So inside of the foreach loop, the first number I look at should be higher than that value. So one way to do this computation is to say, if the current number I am looking at is greater than this highGrade, so this is the greater‑than operator; that's an operator that you'll see in many different programming languages. This is a less‑than operator. This is less‑than or equal‑to. This is greater‑than or equal‑to, and this is the not‑equal‑to operator. What I want to do is check to see if the current number is greater than my high grade. If so, I want to set highGrade equal to the number that I'm currently looking at. So the first time through the loop, highGrade will be the smallest possible floating point value. So the first number we look at has to be greater than that highGrade, either that or the first grade was also double.MinValue, which should be impossible, because our requirements say every grade should be between 0 and 100. Another way to write this would be to use another static member. What I can do is I can say highGrade equals, and there's a math class in .NET, and this math class has many static operations to perform mathematical functions like signs and co‑signs and to find a max value. So I can say, let's compare or look at the number and look at the high grade, and what I want you to give me back is the maximum of those two numbers. So now that you know how to find the highest grade, your challenge is to compute the highest grade, the lowest grade, and the average grade, and write those three values out to the console. So we're already displaying the average grade. You just have to add the logic to find and display the highest grade and the lowest grade.

Computing Statistics
To show the values that we need, let's declare another variable, which will represent the lowestGrade, and I'm going to set that to double.MaxValue, so the largest possible floating point value. And just like we had before, I can say lowestGrade equals, and now let's do a Math.Min. So hopefully you found that operation. What Math.Min can do is give you the lowest of the values. So if I pass in the number and I pass in the lowest grade that I've seen so far, that will give me back the smaller of the two. And I'm going to call this lowGrade, not lowestGrade, only because our other variable is named highGrade, and I just want some consistency there. So either make this highestGrade or change this to just lowGrade. So down here this becomes lowGrade, and now we can write out some results. So let's do a Console.WriteLine that says the lowest grade is and use an expression to place lowGrade into the output. And then I'm just going to copy that line, and I'm going to double‑click to highlight this word and replace it with highest. So the highest grade is and the highGrade. Now let's run this with Ctrl+F5. And of course, we are computing these numbers on the list that we've constructed, so the lowest grade is 4.1, the highest grade is 56.1, the average grade is 17.9. Those all seem like reasonable values because I did, yes, I did add a 56.1 into that list, and so our program seems to be working. But remember, I wanted to encapsulate most of these operations into the Book class. So for your final challenge in this module, what I want to see is none of this code. I want all of us to be gone. I just want to see book.ShowStatistics, let's call it ShowStatistics or ShowStats, and your job will be to complete all these computations against the grades that are being added into the book and display all these results. But all of this code will go away.

Solving the Statistics Challenge
Let's create the ShowStatistics method, and I just want to show you in Visual Studio Code when I have a method that I'm invoking, but it doesn't exist yet, I can place my cursor on that method, press Ctrl+., and generate that method ShowStatistics. So it just saves a little bit of typing. I'm going to select that and come over to Book.cs, and there is my ShowStatistics method. By default, it's going to have this line of code about throw new NotImplementedException. We'll talk about exceptions later in the course. For now, I'll just delete that. It's also using another keyword that we haven't talked about yet, which is internal. We'll talk about that in the next module. I'm going to change that to public, so ShowStatistics exists as an instance method publicly available, just like the AddGrade method. I'm also going to cut this method and paste it above the private field grades just because when I organize my C# code, I like to have all the private members together, typically at the bottom of the class, and I like to have all the public members together, typically at the beginning of the class. So now I have a public method named ShowStatistics, and I just need the code inside to implement that method. So coming back into Program.cs, let's first of all remove these two lines of code. That's back when we were using a list directly here inside of the Main method. We don't really need that code anymore. Instead, I'm going to take this code that we have, cut it out with Ctrl+X, come back to Book.cs, and paste it in. And I don't think I will need to change anything because we still have grades available. It's just now grades. Instead of being a list that is a local variable inside of the Main method, grades are a list that are a field inside of our object of type book. So we're going to look through those grades and compute the lowest grade and the highest grade and the average grade. And now back in Program.cs, hopefully, you're beginning to see what I mean by encapsulation. So, again, picture yourself five months from today. You haven't looked at this course or this program in five months. Now can you tell me what we're doing in the Main method? Well, yes, we're putting together this collection of grades, these three values, and then we're going to show some statistics. If all I need is a high‑level description of this program, it's much easier for me to figure out a high‑level description just by looking at these four or five lines of code. It's much easier than what I had before, which is all the low‑level details of finding a minimum and a maximum and computing an average. It's only if I need details about what's happening with the statistics, what statistics are we computing? Only then do I need to go into Book.cs, look at ShowStatistics, and now I can figure out some of the details that are happening inside of the program. And that's what encapsulation and building a proper abstraction is all about. So at this point, we should be able to run the program. I'm going to run without the debugger, and I can see the lowest grade is a 77.5, the highest is 90.5, and we have an average of 85.7. All of that seems very reasonable and good.

Summary
In this module, we saw some additional syntax features of the C# language. We learned how to define classes. We learned how to instantiate objects. We now have a class that defines public instance members like AddGrade and ShowStastistics. We also have a constructor and some private fields as part of our class. Now, in the next module, we're going to look at testing this class, because in this module, every time I wanted to see if my code was correct, I had to run the program and look at the results. Testing your code provides a number of benefits, but one of the benefits is that you can automate those tests so you don't have to run the program every time you want to see if it's correct or not.

Testing Your Code
Introduction
Hi, this is Scott, and in this module, we are going to learn how to write unit tests in C#. Unit tests are about more than just testing your code. Yes, that's one reason to write unit tests, to test your code and see if it behaves correctly, but I can tell you that unit tests can also teach you about software design and help you write better software. You could also use unit tests to experiment and explore a language and an environment. I hope to show you all these unit testing benefits before the end of this module, so let's get started right away.

The Many Benefits of Unit Testing
I want to show you how to write some simple unit tests in C#. But first, what is unit testing? Testing is easy enough to understand. Testing is trying to prove or verify that our code is behaving correctly. This means if we write code to compute an average grade, I want to make sure the result is the average of all grades. But I also want to test edge conditions. For example, how does my software behave if there are zero grades? Will it give me a result? Will it throw an error? And this is what testing is really all about. Not just testing what we call the happy day scenario where the user behaves the way we expect, but also testing to explore and see how the software behaves when things go wrong, when the user forgets to enter a grade or enters an illegal value. So that's testing. And then what is a unit? Generally, a unit is the source code that we want to test and we went to test small units of code. So in the C# language, we might test the code inside of an individual method that calculates an average, and that method will be the unit, even if the method is part of a larger abstraction, like a class. And finally, it's not immediately obvious, but unit testing is automated, meaning any time we write a test, we can run that test with no effort in the future using a tool known as a test runner. A test runner finds all the unit tests that you have written, executes each test, and gives you a report to tell you if the test passed or if anything failed. And think about it. This is what we've been doing manually in this course. We make changes to the grade book application, and then we run the program to test the results by looking at the output. Unit testing is really just formalizing and codifying and automating that process to make testing easy and fast. I'll be able to make small changes and instantly see if I made a change that creates a bug or fixes a bug. And pretty much every language environment these days comes with a unit test library and a test runner that will help you write and execute unit tests. And C# is no different. In fact, there's a number of unit test libraries available for C# and .NET in general. In this module, we will use a test library known as xUnit. xUnit is not a part of .NET Core itself. It's a separate library that works with .NET and .NET Core. And before we can begin working with xUnit and unit tests, we first need to create a new unit test project where we will write our unit test. So let's look at those steps next.

Creating a Unit Test Project
When we set up the directory structure for our GradeBook application, I created a source folder, placed the GradeBook project inside of the source folder, and I also created a test folder, the idea always being that we would reach this point where we're ready to create a unit testing project because in .Net and with C#, the general convention is to write your unit tests in a separate project separate from your production code and any project that is dedicated to unit testing. So I want to create that project now inside of the test folder. Just like we did earlier in the course, let's go out to the command line. I'm going to move into that test directory, and perhaps you remember, at the beginning of the course, we used the dotnet new command and dotnet new has a number of templates that we can use to construct a new project. We used dotnet new console earlier in the course to create the console application that is the GradeBook application. But now what I want is a unit testing project and you can see there is Unit Test Project, there is NUnit Test Project, there is xUnit Test Project. The framework that I want to use is xUnit. I would say that's a fairly popular choice inside of the .NET Core ecosystem, but you can evaluate some of these other testing frameworks if you're interested to see how they compare and if you like them better because really, it all comes down to what API do you like the best. Which of these do you feel makes the most sense to you or to your team? So I want to do dotnet new xunit, and before I do that, let me make a directory called GradeBook.Tests. So just like we have a folder inside of source for the GradeBook application, this is going to be a folder inside of the test folder for the Tests project. Our project name will take the name of this folder, so GradeBook.Tests, and that's a convention you'll see in many .NET shops where any project related to unit testing will have .tests in the name, but it's inside of here where I went to do dotnet new xunit, this will create my project in this folder, it takes less than a second, and now let's come back out to our editor, Visual Studio Code and there I can see GradeBook.Tests. I can see a new csproj file, so we have a new C# project here, and I even have a .cs file with the source code to my first unit test, it's already been generated for me. Now I do want to point out that unlike our application, which is relying solely on the libraries from .NET Core, our testing project needs some additional libraries because xUnit is not a part of .NET Core. And when we installed .NET Core, we did not receive the xUnit library. XUnit is one of the NuGet packages that is available for .NET Core. You might remember I talked about NuGet earlier in the course. NuGet is a package manager for .NET and for .NET Core. There is over 100,000 packages on nuget.org so you can come to nuget.org to search for packages and these packages, some of them are authored by Microsoft, some of them by third parties, many of them are open source, but they all provide features that you can have access to just by going out and downloading a NuGet package. So this is where you will find xUnit. In fact, if I do a search for unit testing here, at nuget.org, you'll see there is many options here, including different packages for NUnit, different frameworks and libraries and bits of code that will help you with unit testing, but the specific package that I'm looking for would be xUnit, and I just want to drill into the xUnit entry here to show you that on the second tab, this will actually give you the dotnet command that you could execute from the command line if you wanted to add a reference to a NuGet package to a specific project that you have. So when I use dotnet new xunit from the command line, the .NET CLI I already added a reference to xUnit into my project, so I do not have to take this step, but I did want to show you how you can come to nuget.org, you can search here for packages, and if you come to the .NET CLI commands, you can have the exact command that you need to execute to bring that package into your project and start using it. So back in Visual Studio Code, when you do add a package reference to your project, the fact that you've referenced a package will be stored inside of your csproj file. So here, inside of the csproj file, it's an XML file, but you can see I have three package reference elements and one of those is xUnit so that brings in the xUnit library and the API that I can use to write unit tests. And the second xUnit package reference is one that will help Visual Studio execute my tests. So now that we have a new project and we have the xUnit library or the xUnit NuGet package available as a reference, let's take a look at the unit test itself.

Writing and Running a Test
When I created my testing project with .NET new xUnit, the project template created a UnitTest1.cs file, just to show me the basic structure of what a unit test looks like with xUnit. Because every testing framework has a slightly different vocabulary and can work a little bit differently. But here's how things work with xUnit. First of all, I'm going to have a using statement to bring in the Xunit namespace. This is one of the namespaces provided by the xUnit NuGet package, and it's inside of this namespace where I will find the types and the APIs that I need to use to interact with xUnit, the testing framework. This is how I can tell the testing framework that something failed, for example, my test failed. Now my test code will need to be executable statements of C# code, and as we've seen earlier, one way to organize executable statements is to place those statements inside of a method that can be invoked, and a method has to be a member of a type. In this case, this method, Test1, is the member of a class named UnitTest1, and in between, here is the word Fact inside of square brackets. So this Fact is what we call an attribute in C#. The more you program with C#, the more you'll see attributes used in different ways. But here's how xUnit uses an attribute. So first of all, think of an attribute as a little piece of data that is attached to the symbol that follows it. So Fact is a little piece of data that is attached to this method, Test1. And the way xUnit uses this attribute is that xUnit, when it loads up your test project to find the tests inside and execute them and tell you what passed and what failed, it goes looking for methods that have this Fact attribute attached. Because I might have, let's say, three methods inside of this class, but only two of them really represent unit tests. I would decorate those test methods with this Fact attribute. So we talk about attributes like they're decorations that we hang on something like a method. There's a third method inside of this class that perhaps, it's not a test method. It just contains some code that I went to call from the other two test methods to make those methods simpler. But I will not place a Fact attribute on that method, and therefore xUnit will ignore that method. It's only going to invoke the other two as test methods that have to produce a pass or a fail result. And all the test discovery and test execution happens when I run the test runner. So where's the test runner? Well, I will tell you, if you're using a tool like Visual Studio, Visual Studio and some other tools will have a test runner built in automatically. So just go looking for a test command in the menu and you'll be able to execute a test runner directly from the tool. Visual Studio Code has an extension that I can install, just like we installed the C# extension at the beginning of the course, but the extension is the .NET Core Test Explorer. That extension will allow me to execute my unit tests directly from Visual Studio Code. But I'm going to show you that everyone has at least one test runner installed because the .NET CLI includes a test runner. So I am in the folder GradeBook.Tests. This is the folder where my csproj file exists. And if I execute the command dotnet test, this is a lot like saying dotnet run, except now, instead of running the project that is in the current folder, dotnet test will look at the project and say, oh, you must want me to go out and find the unit tests inside of this project, execute those tests, and tell you which ones passed and which ones fail. And that's what's going to happen when I press Enter. The testing framework is going to find that method with the fact attribute attached to it. It's going to execute that test. It considers that test as a passing test. Nothing has failed; nothing was skipped. So my test run was successful. Why was that test a passing test? Because unless I invoke an API to explicitly tell the framework a failure has occurred, the testing framework assumes everything has worked well and everything has passed. So let's jump back into the editor, and I'll show you how to tell the framework about a pass or a fail. So ultimately, the API that you are going to use is an API provided by a class named Assert. So this is in the xUnit namespace. And if I use the dot operator in the IntelliSense window, I can see a number of different static methods available in that class that I can invoke to check different conditions or to make assertions. For example, I might want to make an assertion that some object is the same as another object. I might want to make an assertion that some string matches some regular expression that I provide. Or I might to make an assertion that something is not null or something is null. All of these methods I can pass in parameters, and if the method finds out that something I say is not null is actually null, it will register a failure with the test runner and I will find out that this test failed. Let's look at a simple one. Let's look at Assert.Equal. So with Equal, I pass in two values and the Equal assertion will make sure those two values match. And we usually think of these two values as the expected value and the actual value. So the expected value is what do I expect the result to be? What is the correct answer? And the actual value is what did my code actually compute? So let's try this out. I'm going to try this out in a simplistic fashion. We're not actually going to test anything in the GradeBook project just yet. Instead, let's just declare some variables and do some addition right here inside of Test1. So let's say I have a variable called x and I set that equal to 5, and I have a variable called y and I set that equal to 2. And then I say the actual value that I have computed is x * y. As we all know, that answer should be 10. But let's just say that we are expecting a result of 7. So down here with a Assert.Equal, I will pass in the expected result. What did I expect to see? And I will pass in the actual result, or what did my code actually do? Now I'll save that file. Let's come back out to the test runner, do it dotnet test. After a second, I will have lots of red text scroll by, which indicates a failure. And, yes, I can see there was an Assert.Equal failure. So I expected the value 7. My actual value that came out was a 10. This happened on line 18 in UnitTest1.cs. So now I have all the information to go back into my code and try to fix this problem, potentially even run the debugger to try to figure out what's going wrong. Of course, in this case, it's very obvious because all of our code is right here inside of the test method. But typically, this little bit where you compute the actual value is calling in to something that is inside of a grade book or inside of an invoice object or inside of some sort of service that computes the amount of tax on a sale. But let me just change this code to x + y, save the file. We'll come back and run dotnet test again, and after a second we should have a successful test run again, which is good. So this is the essence of a unit test. If you do some further reading and training on unit tests, you'll typically find most people want to break up a unit test into three sections. First, there is the arrange section. This is where you put together all your test data and you arrange the objects and the values that you're going to use. Then there's the section of the unit test that we call the act section. This is where you actually invoke a method to perform a computation or perform a calculation. You actually do something that produces a result, the actual result. And then you have the third section, which is the assert section, where you assert something about the value that was computed inside of act. So triple a, arrange, act, and assert. And now let's take what we've learned about unit testing and try to apply it to the book class in the GradeBook project. Ultimately, what we want to do is make sure that book computes the proper statistics.

Referencing Projects and Packages
My ultimate goal is to write unit tests that will verify the logic inside of the Book class that lives inside of the GradeBook Project. And because of this, I want to rename this class. I believe names are very important in software development. And, remember, what we're trying to do is build the proper abstractions. A proper abstraction requires a good name, and a name like UnitTest1 doesn't tell me anything about what might be inside of this class. If my intention is to write tests related to the book here inside of this class, then I would rather call this BookTests, and that's a convention that you'll find in many projects. If there's an Invoice class and an Employee class, then you'll probably find in the test project InvoiceTests and EmployeeTests. And another good convention to follow is that your file name should match the class name. So if class name is BookTests, I also want to rename this file to be Book.Tests.cs. So this is a good first step. And then if I'm testing the book, I don't want to arrange just arbitrary integers in here. This is just something we were experimenting with. I want to create an actual instance of my Book class, and you might remember a book requires a name. I'm just going to pass in an empty string, so two double quotes. And is that legal? Well, that's a good question to ask when you're writing a unit test. Perhaps you need to go back to a business owner and say, Is it legal to have a book with an empty name? If not, I need to write a test that makes sure the book throws an error when I initialize it with an empty name. Otherwise, I might consider writing a test to make sure the book doesn't throw on error when I give it an empty name like this. And now, because this line of code influences what happens throughout the rest of the method, let's just for now delete these other lines of code. I will leave the comments in place, but what we want to focus on first is how we can gain access to the Book class because right now I have an error. The type or namespace Book could not be found. Are you missing a using directive? Now if you use the tip that I showed you earlier in this course, then you might place your cursor on the book identifier and press Ctrl+. to get the drop‑down. Now previously in the course, we were able to fix a problem like this just by saying, Yes, add a using statement. But here in the list of possible items, I don't have an option to add a using statement. Instead, I have options to do things like create a new class and a new file. That's not what I want to do. I want to use the book that I already have defined, but it's in the GradeBook project. And here's what's happening. When I'm writing code inside of a project, like when I'm writing the code inside of the Main method here inside of the Program class, I have access to other classes that are in the same project. That's no problem. But if I try to access a class that is in a different project, then I need to tell the C# compiler I am using this other project, and when you come across something like Book, please look in these other projects to find that particular type. Currently, we don't have any information associated with GradeBook.Tests to tell the C# compiler to look somewhere else. We do have a NuGet package reference. NuGet essentially allows me to do the same thing. I can say, Go out and reference this NuGet package xunit. And then when you come across an identifier like Fact, make sure you're looking inside of the libraries associated with this NuGet package to find this particular type. And then, of course, we just have to have the using statement in place for the C# compiler to be able to find that type. But before we can even do that, we need to have a reference to this other library. How do we do that? Well, if you're using Visual Studio, it's very easy to right‑click on your test project and say that you want to add a reference to another project, and then just point Visual Studio towards your GradeBook project. I want to show you how to take the same steps, but using the .NET CLI. So out here at the command line, I am going to type the command dotnet add. With dotnet add, I can do one of two things. I can add a reference to a package, so I can add a reference to a NuGet package. So if I did a command like dotnet add package and the name of the package like xunit, well, I already showed you this command earlier in this module when we were looking at Nuget.org. This would be a way that I could add a reference to xunit from a project if the template hadn't already provided that for me. In this case, the class that I want to use, the BookClass, is not in a Nuget package. It is in another project. So what I want to do is add a project‑to‑project reference to this project. So I went to type dotnet add reference, and let's just press Enter to see the help text that comes up, and I can see that I just need to specify a path to the project file. So let's try this again. Notice I am in GradeBook.Tests, by the way, when I'm doing this. So I want to dotnet add a reference to the project that is in this current folder, and the project that I want to reference, it's going to be up to, that will place us into the top‑level folder. Then I want to go into the src folder, into the GradeBook folder, and inside of there should be GradeBook.csproj. That is the project that I want to reference, and when I press Enter to execute that command, I can see the reference was added to the project. What does that do behind the scenes? Inside of my csproj file, in addition to my NuGet PackageReferences, I also have a ProjectReference, and I can see their relative path here into GradeBook.csproj. You can have as many ProjectReferences as you need for a given application or a given library. It's easy to find complex systems out there that have at least a dozen projects inside, and they reference each other in this fashion. But now that I have that ProjectReference, if I come back out to my CS file, the error message has changed. So now the C# compiler is looking in that other project, and it is finding the Book class, and that's why the error has changed. The error has now changed to say that Book is inaccessible due to its protection level. We saw a similar error message earlier in this course when I tried to invoke a method that was not marked as public. We have a very similar problem here. If I look inside of Book.cs, I can see there is no access modifier associated with my class. I do have an access modifier of public on all of the methods that I want to expose, but it turns out that when a class definition, if you do not explicitly specify an access modifier, you will be given essentially an access modifier of internal. Internal means that this class can only be used inside of the same project. So I could only use this Book class inside of the GradeBook project. What I want to do is expose this class so it's available to my unit testing project. So I'm going to again used the keyword public, just like I have on my methods, and that's telling the C# compiler anyone who references this project has the ability to consume and use this particular type. So, again, this all goes back to creating the proper abstractions and using encapsulation. If Book was an implementation detail that I only needed inside of this project, then I could leave it as an internal class so other developers don't see it and worry about it and think they have to use it. But in this case, I do want to expose the Book class. It's a primary abstraction that I'm building for the GradeBook, and at the very least, I want to be able to test this class. So I'm going to make it a public class. And now if I come into BookTests.cs, I have legal code that will compile. Now many times there's one more step that you have to take. So once you find out what project or what library or NuGet package that a type exists in, you have to add a reference to that package or to that project, and then you have to add a using statement to make sure you bring the namespace into scope for that class. In this case, we are in a namespace that is underneath the GradeBook namespace where the book exists. So in this case, I do not need a using statement. So I already have access to everything that is in the GradeBook namespace without having that using statement. And so now for an arrange, what I would typically do is something like add some data into the book. So let's add a grade of 89.1. Let's also add a grade of 90.5. And let's also add a grade of, let's do a 77.3. So this is the arrange section of my test. I'm arranging the data to act on. And down here is where I would say, Dear Book, I want to ShowStatistics. Ideally, this would compute a result that I could write and assert on, but currently ShowStatistics does not return a result. Let's talk about that in the next clip.

Refactoring for Testability
Ideally, when I invoke ShowStatistics on my book, I would get back some sort of result that I could write asserts on. So my code would look something like declare a variable named result, allow that to capture whatever ShowStatistics returns, and then I would start writing asserts on that result. So I could say things like Assert.Equal, and let's say that we're going to look at result.Average. That's going to be an actual number because that's what our software computed. And I'm going to compare that to the value 85.6, which is very close to what the average should be given these three grades. So ideally, this is the type of code that I want to write. In fact, it's the type of code that I need to write if I expect to be able to properly unit test my class, and this is one of the great, great features of unit tests. It's a fantastic side effect of writing unit tests, and that's one of the reasons I encourage people to keep writing unit tests even when they become discouraged. And what I'm talking about is that sometimes your unit tests force you to have a better software design. And at the end of the day, what we want is working code, so yes, code that produces the right result. But we also want a good design and a good architecture and the type of code base that we can come back to in 5 months and still work on it or the type of code base where I can bring in other developers, and they can understand what I'm doing, and they can make changes to that code base to add new features. So sometimes I use unit tests to prove that a piece of code works, but sometimes while writing those tests, I uncover something about my design. And here's what I'm uncovering about the method ShowStatistics. It's doing too many things. If you try to describe what a class does or what a single method does when it executes and you have to use a conjunction word like and, there's a chance that that class or that method is doing too many things, and you need to break that method up or break that class up. So what does ShowStatistics do? Well it computes the average grade and the highest and lowest grades, and it shows those grades on the console. So this method has a lot of different responsibilities. Not only is it doing the computation, it is also displaying the results of that computation. And one thing you're going to learn about software, particularly if you write unit tests, is that you want to build smaller pieces, and you want to separate the deciding from the doing. So I went to separate executing the calculations from displaying the results of those calculations. Those are two vastly different responsibilities. And by separating those things, I can build smaller pieces, and that's always the goal. One of the problem areas I see with new developers is that they tend to write large methods, and they tend to write large classes, and these large abstractions are difficult to maintain. You want to strive to write smaller methods and smaller classes. So here's what I want to separate. I want to separate the calculations from displaying the results of those calculations. So instead of ShowStatistics, what I want is a method, ComputeStatistics or GetStatistics. Let's use GetStatistics. So all I want this method to do is compute the statistics. And I went those statistics returned in an object that will carry those calculation results. So I want to be able to say yes, this is result.Average. And I want to be able to say that if we were to look at, let's say the highest grade, I would expect that to be the 90.5, so result.High. And let's also do an Assert.Equal on 77.3 that this is result.Low. So what I'm doing here is I'm writing code that doesn't exist yet, but it gives me a good idea for the type of class that I want. So first of all, I'm going to have to rename this method. So let me copy this. Come back to Book.cs. And instead of ShowStatistics, we're going to write a method or have a method named GetStatistics. And now, instead of returning void, which is really saying instead of not returning anything, I need this method to return an object and an object that has the following state associated with it, an average, a low, and a high. How do I construct an object? I construct an object from a class definition. So let's write a class definition, a class that will have the fields average, high, and low. And this class doesn't have any other responsibilities other than being able to transport and carry the results of statistical calculations. So I want to create a new file. Let's call it Statistics.cs. And inside of here, I do want a namespace of GradeBook. So I want to make sure my class is inside of that namespace. And I will want a public class called Statistics, so the same as the file name. And now let's use the public keyword to say I want a field of type double whose name is average. So coming back into BookTests.cs, that will allow this line of code to compile. I also need a high and a low. So this is very similar to the field definitions we did before or the field definition that we did before inside of Book.cs when we declared a field of type list of double. Now I'm just declaring multiple fields, and this field will hold the high value. And the next field I declare will hold the low value. And of course, the difference is that these fields are public. I'm not going to hide them. Sometimes you want to make your state available to the outside world. Other times you want to hide your state because it's an implementation detail, like the list of grades that we have here. But now that I've made these changes, I need to change GetStatistics so it actually constructs a new instance of this class and returns this class as the result of invoking GetStatistics. So let me copy this class name, come back to my GetStatistics method. And the way that I tell the C# compiler that this method returns an object of type statistics is to use that class identifier here, Statistics. So this is a public method named GetStatistics, and its return type, that is the type of object it's going to return, is Statistics. I could also have it return a double, so that would return a single floating point number. Or I could have it return an integer. Or I could have it returned a list of floating point numbers. But no, what I want it to return is an object of type Statistics. In order to return an object of that type, I will need to construct or create an object of that type. So let's say that result, instead of being equal to 0.0, let's say it's a new instance of Statistics. So now I have a variable named result that holds a value that is a reference to an object of type Statistics. And I could say that I want to initialize every field inside of here. But technically, this is already done for me by the .NET runtime. So it's going to make sure that all the fields inside of a particular class when it's instantiated as an object, they will be set to what we call all bits off, so all bits in the memory space are 0. And that means for a floating point number, the value would be 0. But I do want to have high and low be these special values so we can perform the calculations correctly. So let me say results.High equals the minimum value and result.Low equals the maximum value. And now I just need to continue to fix up my code to adjust for this refactoring. So down here instead of the loop, we no longer have a variable named lowGrade. Instead, I want to go to result.Low and compare it to the existing result.Low. So really, this is just a search and replace operation for the most part. This is a result.High, and it's going to compare that to result.High. And finally I could also say result.Average, that's where we're going to sum our grades as we go along. In fact, I would actually rename this variable. This is how particular I am about names. This is not just a number that comes out of anywhere. This is, in fact, a grade that is in our list of grades. So I would want to use grade here throughout the rest of the method. So let me replace number with grade everywhere I see it. And then finally, I can say that result.Average is result.Average divided by grades.Count. And then finally what I would do is remove these lines of code that are displaying the result to the console because I don't want that to be the responsibility of GetStatistics. So I'm going to Ctrl+X and cut those lines of code out from here. If I want to display the statistics, I will do that somewhere else once this method returns those statistics. So how do I return these statistics that I've computed? Well, I use the return keyword in C#. So I can say let's return the result that we've computed, and that will be an object with the fields average, low, and high populated with hopefully the correct results, but we'll find out in just a second. I could go into Program.cs at this point and modify this to make sure that things work because, remember, we renamed ShowStatistics to GetStatistics, so I'm going to make that change. And we're now returning statistics, so let's just declare a variable named stats. That's going to be equal to the value that is returned by GetStatistics. I'm going to paste in the code that I cut out of Book.cs because I do still want to display these statistics to the console, but now I also need to fix up this code. This is what we call refactoring. When your unit tests force you to redesign your code, you refactor that code to improve the design. So that's stats.Low, this is stats.High. And finally, I would have stats.Average. Let's save all of our files. Remember, the goal is to execute this unit test, which places these three grades into a book, tries to get the statistics, and then we write assertions to make sure that we're computing the correct results. Let's go back out to the command line. And what I want to execute while I'm inside of the GradeBook.Tests folder is dotnet test. Once this executes, I will see that there is a bit of a problem. And the problem is I expected the value 85.6, but the actual average that was computed by my code is 85.633333. Now if you've been programming for any length of time, you might already recognize what the problem is. And the problem is that when you're using floating point numbers, it's very easy to get into these conditions where a little bit of a loss of precision can force you to fail when you're trying to compare two numbers exactly. So when I write in my unit test that I expect the actual result to equal 85.6, that means 85.6 exactly, and something like 85.633, which I could easily round down to an 85.6, that's not an exact match. So any time you're trying to do an exact match with floating point variables or floating point numbers, that's a potential problem. Fortunately, most unit testing frameworks will give you a way to solve this problem in an easy fashion. And in this case with xUnit, when I look at Assert.Equal, there is third parameter that I can pass to this method, and that third parameter is the precision, so the number of decimal places that will be used in the comparison. So I can say I only went to check to one decimal place. Let's do that for not just the average, but also the high and the low, save all our files, come back out, run a dotnet test, and now all my tests are passing.

Summary
In this module, we spent some time refactoring our book class, and I didn't give you any exercises to try on your own. That will change in the next module, because before we continue to add features to the grade book, I want to cover two important topics that have been lingering around since the beginning of this course. So over the next module, we are going to use what we've learned about unit testing to explore and understand reference types and value types in C#.

Working with Reference Types and Value Types
Introduction
Hi, this is Scott. And in this module, we are going to look at the two categories of types that you can create in C#, reference types and value types. Understanding how these types behave is important to writing software that works correctly. We're going to see how we can pass values and references between methods in this module. So you will have a firm grasp on how parameters behave, too. We're going to do this by writing and exploring with our unit test project, so prepare yourself for writing some tests.

Reference Types and Value Types
The topics in this module are topics that if you keep programming in C#, you'll eventually become so comfortable with these topics they'll become second nature. Since you're just beginning, we're going to spend the entire module focused on the difference between values and references in C#, because I've been using terms like object reference and return a value, and now we get to see what those terms really mean. So let's use the following two examples. First, let's talk about a piece of code that creates a new variable b and assigns to b a reference to a new Book object. So any time you are working with a class, any time you write a class or any time you use a class provided by .NET or some other NuGet package, you are using what is known as a reference type. And what I want to do is explore how reference types work in memory. So imagine this big purple box as representing all the memory that is available on your computer. So first, that line of code would force the .NET runtime to create a space in memory for the variable b, because we need memory to store values that are inside of variables. And by the time that statement finishes executing, there will be a value in the letter b. This value might be something like the value 1072 because this value really represents a memory location. So somewhere in the megabytes and probably gigabytes of memory on your computer, there will be memory cells where the .NET runtime allocates space for this new Book object that you want to create. And this value 1072, inside the variable, is the address or the location of where the book is in those gigabytes of memory that are available. So we talk about the variable b really being a reference or a pointer to where the book lives on your computer. The variable doesn't contain the book, just like an email that I write to someone else doesn't contain that other person. But I can use an email address to reference the other person and deliver mail to them. So later in the code, when I do something like b.AddGrade, the .NET runtime can follow the reference in my b variable to find the right book, and that might be one of 10,000 books that you've created in memory. But I can find the right book given the address, and from that book, the .NET runtime can also find the name of the book and the grades that are associated with that specific object because those are the fields or the state that is a part of each book, and those fields are actually references themselves, so references that would point to other locations in memory. And now let's compare this to another line of code, which is x equals 3. Three is an integer and integers are special types in .NET. Integers are what we call value types in .NET. And here's why. For a value type, the runtime still creates space for my variable x, but now, instead of storing a reference inside of the variable, I store the value itself. So there is no pointer to an integer that's somewhere else in memory in this variable. There is simply the value of the integer, and it's stored directly in that variable. Now there's many simple types in .NET that are value types and they behave this way. So integers and floats and doubles, those are all numbers, and they all are value types. I'll show you how you can create your own value types and also show you how to tell if you are working with a value type or a reference type later in this module. But for now, let's just focus on the difference between a variable that holds a reference and a variable that holds a value. B holds a reference because it's typed as a book and book is a reference type, x holds a value because it's typed as an integer and int is a value type, and one points to another location or references an object, and the other one holds a value itself. If this doesn't sink in right away, don't worry. It can take some time, and we are going to spend some more time on this topic by writing some tests.

Creating a Solution File
Before we get to work in this module, there's something I want to do to make the work easier. Because what we're going to start doing is making changes inside of the GradeBook project and also inside of the GradeBook.Tests project. And that means I'm going to need to build both of these projects and run tests in the test project. And I don't want to go to the command line and keep switching directories to build the different projects. I just want to be able to go to one location and say, build everything and test everything you can find. And the way I can do that is by adding a solution file. A solution file of something that tools like Visual Studio understand and also tools like the .NET CLI understand. And what a solution file is, it's really just a file that keeps track of multiple projects. So if I add all of my projects to a single solution file, I can open that solution file using a tool like Visual Studio, and all my projects are loaded in for editing, or from the command line, I can use a tool like the .NET CLI to say please do a .NET build and it will build all the projects it finds in the solution, or I can say .NET test, and it will find all the projects that are unit testing projects in that solution and run my unit test. And creating a solution file is very simple. Let's go out to the command line. I am in the top level folder for my collection of projects, the gradebook folder. This is the folder where the source and test folders exist. And what I want to use is the dotnet new command. And I want to point out that one of the templates available with dotnet new is the template that will create a solution file. So the solution files have the extension .sln. So the shortcut name for this is dotnet new, and then just specify sln for solution file. That will place into this folder a file that has the same name as my directory. So I have gradebook.sln. That's the solution file. Now what I want to do is add projects into that solution file. I can also do that with .NET, and it's very easy, I want to dotnet sln add. So these are operations associated with the solution file, dotnet sln add, and let's go into the source folder and go into the gradebook folder and find GradeBook.csproj, I want to add that project to the solution, and then I want to dotnet sln add in the test folder. Let's go to the Tests folder and find the csproj file there. That is now part of my solution. And now what I could do, if I'm using a tool like Visual Studio, is just open the solution file. But I can also do things like dotnet build, and what dot net build will do is look for a solution file in the current directory. We've seen previously in the course where dotnet build will look for csproj files, but now it will find the solution file and say, oh, you must want to restore and build both GradeBook.csproj and GradeBook.Tests.csproj. And now I can come to a single location just to do a dotnet build and also a dotnet test, and all of my projects will build and all of the unit tests across all of my projects will be found and executed. So this is going to make our work much easier as we move forward.

Testing Object References
For our first set of tests in this module, I want to focus on this scenario where we have a method that constructs a new instance of a class, so a new object, a new reference type, and then returns that reference to the caller. Some of the questions you might have about this scenario include, does this method always return different objects, or does this method always return the same object? Those are valid questions, and I would encourage you to keep a unit testing project around that you use purely to answer those types of questions and experiment. It's a good way to gain experience not only with the C# language, but also to understand how .NET behaves. And I would even check that project, that experimenting project, into a place like GitHub, so you can keep it around and take it with you, and you could have it as a private repository, but you'll never lose this code that you're writing and building on to explore the language and the framework. Now, my goal is that we're going to write a test that instantiates the Book class a couple different ways and then tries to keep track of book objects using the book name. Right now, this name is private, so I only have access to the name when I'm inside of the book. I'm going to change this, and later in the course, I will show you a better approach to do this, but for right now, I'm just going to make this field public. So I will be able to access name from code outside of the Book class. And I'm also going to change name to be uppercase N Name. So the convention in C# and .NET is that when you have a public member, whether it's a method or a field or some of the other member types that we'll look at later in this course, that public member always has an uppercase Name. So this will be uppercase Name, and that means I need to make a change in the constructor because C# is a case‑sensitive language, so it no longer sees lowercase n name, it no longer sees that field. There's only the uppercase field. And now I can also get rid of the this keyword because now the C# compiler can differentiate between Name the field with an uppercase N and name the parameter with a lowercase n. So, those are all the changes I need to make to book.cs. I'm going to save that file and close it. And now what I want to do is write some new tests. Now these new tests are not centered around the book, so I want to put them in a new class and in a new file, and I also want to rename this particular test. The name currently is Test1, and that is a name that I always like to get rid of because it gives no indication as to what's actually happening inside. When you're writing your test classes and your test methods, it's important to name them properly; it's just as important as the other classes that you write for your regular code. And typically, what you want to do with a unit test is make some statement of fact about your software. That's why we have this Fact attribute, and that's why xUnit chose the word Fact to identify tests. We're trying to prove a fact about how our software behaves. So I could say that the BookCalculatesAnAverageGrade. Or I could say that it calculates stats, statistics, but this name, BookCalculatesAnAverageGrade, is far better than unit test was, so we'll stick with that. And now what I want to do because I want a new class that has tests inside of it, I also want a new file, I'm going to use BookTests.cs as a starting point, and I'm going to make a copy of this file to get started with my new class. So right‑click on the file and say that I want to copy the file, go to the folder Gradebook.Tests and right‑click on that and say that I want to paste the file. If your new file doesn't show up, you can always hit the Refresh button here in the Explorer. But I can see BookTests1.cs or BookTests.1.cs. I want to rename this. What we're going to do are some type tests. So, how do reference types behave? How do value types behave? I'll call this TypeTests, and that means at the start of this file, the class name will be TypeTests, and then inside I can start thinking about the first test that I want to write. For right now, yeah, sure, I can just call it Test1. I have no problem with that when I'm just starting to write the test. But once I figure out what it is I'm really testing, then I want to rename this method. So what I really want to do inside of this test, and again, just to explore a little bit, I'm thinking I want to invoke a method that will instantiate a book, and then I want to write some sort of test that can prove or disprove that every book that is returned from that method is the same object, or it's a different object. So let's create one variable named book1 and invoke a method named GetBook, and let's imagine that we can provide every book a name. A book has that capability. So let's call this book Book 1, and then I want to do the same thing, but with a different variable, Book 2. Before I get that far, though, let's create this method, GetBook. One way to do that is to place the cursor on the method and press CTRL+period. I've shown you this tip before. This will generate that method for me. Notice this is a private method, and that's fine. Remember, you can also leave the private key word off, and that's the default for a member. By default a member is private. I do not want to place a Fact attribute on this method because this is not a unit test in itself, it's just another method that I call from a unit test somewhere else. Right now, the return type of this method is object. Object is the lowest base type in the .NET Framework. We'll talk about that later in the course, but what I really want to return from here is a book, so I'm going to change the return type to Book. So remember this identifier to the left of the method name here, this is describing the return type. Avoid would be a way of saying this method doesn't return anything, but we do want to return a book. We're passing in a string parameter that is really supposed to be the name of the book, so I'm going to change that from V over to name. So, again, all the names should make sense. And now I'll write a very simple expression. What I want to do is return what happens when I use the new key word to construct a new instance of the Book class, and I pass along that name parameter. So that's a simple implementation for this method. And now, if I have the variable Book 1, and then I declare another variable after I copy and paste that line, but we'll call this variable Book 2, and I give this book a different name, the question I have for you and the challenge for you is to write an assert statement where you assert that something is equal to book1.Name and something is equal to book2.Name. So if you believe this method always returns the same object, then perhaps both of these books will have the same name. Perhaps they are both going to be book2 because that's the last time that we invoked GetBook, and that's the name that we passed in. Otherwise, if you believe this method is returning different objects, then you might put the expected value in here as Book 1 and Book 2. So, pause the video, make this test pass by putting in the correct expected values, and then we'll come back and review the correct answers in the next clip.

Referencing Different Objects
So back at the command line, I can be in my root folder, the gradebook folder, and from here I can run dotnet test. Dotnet test will find the solution file that we created, look at all the projects inside, find the unit testing project, and run all the tests inside. And you can see I have now two passing tests. And that's because back in the editor, what you should have found is that every time I invoke GetBook, I'm creating a new and unique and distinct object in memory. So the first book can have the name Book 1 and the second object can have a different name. So different pieces of state in those two different objects. And that's why I renamed this method as GetBookReturnsDifferentObjects. So you always want to give a real meaning, a real name to your unit testing methods, and this is stating a fact about how the method GetBook behaves. So here's another question you might have. Can two different variables reference the same object somehow? Let's try to figure that out. What I can do is make a copy of this test. I'm going to paste it down here. I'm going to line things up, and I'm going to change the name. So I want to say that two variables can reference same object. How can I do this test? Well, let's keep the code that says book1 equals GetBook with the name of Book 1. But now let's just say that we want to declare another variable, book2, and set it equal to whatever value is inside of book1. Remember, variables hold values. They always hold values, it's just that those values can be references or can be pointers to an object that is out there in the memory of my computer. So the variable book2 is always going to contain a value, it's just what is that value that goes into book2? Is it a reference that points to a different book? Because does this line of code somehow copy the existing book object that we've created in memory? Or do we simply take the reference or the pointer that is the value inside of book1 and copy it into book2? How can we check this? Well, one way to check it would be to assert that both the variables point to an object that has the name Book 1. But let me show you another way. What I can do is I can use some other asserts. So there is an assert that xUnit provides called Same where I can assert that book1 and book2 point to the exact same instance. So verifies the two objects are the same instance. So both of these references would be pointing to the same object in memory. That's like up here, I could say that I want to assert that book1 and book2 are not the same. So we know that these are two different objects because they contain two different names. But we want to test if Assert.Same is true. And then I want you to write one additional assert. Assert.Same is really, behind the scenes, doing something similar to this. It's asserting that Object.ReferenceEquals is true. So first of all, ReferenceEquals is a method, a static method, that is available on a class named Object in the .NET framework. When we talk about inheritance later in the course, we're going to find out that everything in .NET derives from this Object base class. But ReferenceEquals, you can pass in two parameters, like book1 and book2, and ReferenceEquals will tell you if these are the exact same references. So are the values inside of these variables pointing to the same object? If so, ReferenceEquals would return true, and this assertion will work. A nicer way to do this with xUnit thought is to use Assert.Same. Now if I come back to the command prompt and clear the screen and run dotnet test again, we should be able to find that that test, our third test, is also successful. So now we know that, yes, two variables can reference the same object. They can reference different objects, but because variables always hold a value, they don't hold the objects. They can hold values so that both of them can point to same book.

Passing Parameters by Value
So in this clip, I want to give you a new challenge. But before I give you that challenge, I want to make sure that you understand the implications of this line of code right here. So when I say book2 = book1, I'm not making a copy of some book object and placing that into the book2 variable. Instead, what this line of code will do is take the value that is inside of book1, that value is a pointer to reference, and we're going to copy that value into the book2 variable. So we will have the same pointer value where a pointer is just some number that's going to lead us to some memory cell that's in our computer. So keep that in mind as I write our next test. What I want to do is write something that will check to see if we can change the name of a book and how that happens. So I'm going to make a copy of the test that we already had, which is GetBookReturnsDifferentObjects, but I'm going to change things around a little bit. First of all, I have to change the name of this test. Let's just call it Test1 for now until we, again, figure out what we're doing. Let's just create a single book, and we'll start that book off with the name of Book 1. But now I want to invoke a method called SetName, and I want to pass in that book as a parameter to the method SetName. And I want to pass along a different string, which will be the new name for this book. So let's call this New Name. Now before I set you off for your challenge, let's create this method. So again, I can use Ctr+period and generate this method. That will generate the method right here. Being a private void method is okay. We are going to take a book, and we are going to take a name. And then all I want to do is say this book's name field should be equal to this incoming name parameter. Now the challenge for you again is to write an assertion that works. So I want you to write an Assert.Equal on book1.Name. And the question is, what will this calling unit test method see? Will it see the value book1, which is the original name that we gave to the book? Or will it see this new name? So keep in mind what will happen here. Put in the value that you think we'll see, and then come back for the next clip to see the answer.

Returning Object References
As you should have discovered, I do have the ability to change the name of an existing book object by invoking a method and setting the name field on a book object. So I'm invoking a method, I'm passing along a reference to book1, as well as a new string, the New Name, and I can then assert that this book object referenced by book1 does have that name. So I named this test CanSetNameFromReference because what I'm passing to this method is a reference. But I want to be very clear about the terminology here. In the C# language, when you pass a parameter to a method, you are always, 100% of the time, passing a parameter by value. So perhaps you've heard of these terms pass by reference versus pass by value. Perhaps you've heard them in other programming languages because it describes how a parameter is given to some method that you're invoking, and in C# the answer always, always, always, 100% of the time, unless there's another keyword involved, the answer is always you're passing by value. And what that means is that I'm taking the value inside of book1, and I'm copying that value and placing it into this parameter book. It's a lot like saying book2 equals book1. I'm taking the value inside of the book1 variable and placing it inside of this variable. In this method call, I'm taking the value that is inside of book1, and I'm placing it into this parameter book. So it's a copy of that value. It just so happens that that value represents a pointer to a memory location. So it's a reference to a book object. And that would be very different if I was in an environment where this language and this run time would pass parameters by reference, because then this book parameter would receive a reference to my variable book1. And then, yes, this parameter could still make changes to the object, to that book object, because my parameter hold a reference to a variable that still holds a reference to my book object. But in a pass by reference scenario, I can even make changes to that book1 variable itself from the other method, and that's something that cannot happen if I use pass by value. So let me give you another test, another scenario to evaluate. What I'm going to do is make a copy of both this unit test, CanSetNameFromReference and this method SetName. I'm going to make a copy with Ctrl+C of both of those, and I'm going to, up here, paste them in, and we're going to change them around a little bit. So first of all, let's call SetName something different. I'm going to see that this is SetName. I'm going to say the new name of this method is GetBookSetName, because I want to do two things. I want to say that book equals a new Book with the incoming name parameter, and then we don't really need the second line of code. What we're doing when I say new Book and passing in a name is we are constructing a new Book instance and we're setting the name by passing that name into the constructor. And now so we don't conflict with the other method name, I want to change this to be, for now, just Test1. And now I'm going to leave it up to you. I want you to put in the value that you expect to see here for Assert.Equal, and then run the test and see if you got things right. But of course, we're also going to have to invoke this method, GetBook and SetName, and I just want to remind you about what's happening behind the scenes, book1, the value that is inside of this variable, is now a reference to an object that was just created by the method GetBook. And now, when I invoke GetBookSetName, what is being passed along as a parameter is a copy of that value. So let's just say, to make this a little more concrete, that the value inside of book1 is the value 10. So our book was created in memory location. 10. What we're doing is taking that 10, copying it into this parameter, and now the question for you is when I say that book equals a new Book, am I writing that value into the book1 variable? Is there a way for this method to reach out and touch my book1 variable or am I just making changes to this local parameter? If you think you're just making changes to the local parameter, then the assert here should be an assert that book1 is the expected value. But place in the value that you expect to find, run your test, and then see if you're correct. We'll come right back and explain the answer.

Passing Parameters by Reference
As you probably discovered, this new test that we wrote, which I named CSharpIsPassByValue, in this test the name of the book at this point is still Book 1, because again, what we did was, when we invoked GetBookSetName, we made a copy of the value that is inside of this variable book1, and we placed that copy in this parameter. So this line of code is constructing a new Book object, and we're storing a reference to that object in this book variable, which is a parameter to this method. But this parameter is different from the variable location that is up here in this method. Those are going to be two different memory locations. We're storing that value into a new, different memory location. So this variable book1, the reference that it holds is not going to change when we call this method, and that's exactly what the designers of the C# language wanted. When you pass a variable to another method, you don't want that other method to unexpectedly change the value or the reference that is inside of your variable. That would be an unexpected side effect of invoking that method. And just for fun, I even added the line of code here that says, look book.Name = name. I'm going to try to force the name into the object that we created up here. But again, since book, since we have created a new book object and placed a new reference value into this parameter, this is not working with the same book object that we worked with up here with book1. Now, if this is something that I want to do, if I want to be able to make changes to the variable that is passed to this method, then I can change this method so that the parameter is passed by reference instead of by value. So remember, the default is always, always, always to pass by value, but I'm going to copy CSharpIsPassByValue and GetBookSetName. I'm going to copy and paste those two methods again so we can change them around. This method I'm going to call CSharpCanPassByReference, or let's just call it PassByRef, and then on the method GetBookSetName, I'm going to add a new keyword in front of the first parameter, which is the ref keyword, and that tells the C# compiler that when this parameter arrives, or whoever calls this method, this first parameter will be passed by reference and not by value. By reference means what I will receive is not a copy of the value that is in a variable that I pass along. Instead, what I will get is a reference to the memory location of where that variable is stored. And because this method now has a reference to this variable, to that memory location, I can now, from inside of GetBookSetName, I can now make changes to the value that is inside of the book1 variable. Now, in order for this to work and in order for me to invoke the proper method here, GetBookSetName, I also have to use the ref keyword here. The C# designers wanted to be sure that whoever is calling a method that is using pass by reference will be aware that they are passing a variable by reference, and that means the variable could be changed. So now remember, the only real changes I've made here are that I've added the ref keyword to my first parameter, and I've added the ref keyword here where I am invoking the method GetBookSetName. And now the question is, will I see Book 1 here, or will I see New Name? Why don't you pause the video and give it a try? Place in the value that you expect to find, and then come right back. So what you should have discovered is that, yes, this book1 variable, after we invoke this method and pass book1 by ref, the book1 variable is now pointing to a different object, and this object does have the name New Name. So that's how we can pass by ref. I will say that in day‑to‑day programming, you do not pass parameters by reference that often, so you won't see or use this ref keyword very often. There are some APIs that demand it. But I will point out that there is an alternative to ref, which is the out keyword. The out keyword also does a pass by reference so this test will still pass. It will still behave the same. The only difference between ref and out is that with an out parameter, the C# compiler assumes that the incoming reference has not been initialized, and so it will be an error if you do not assign to an out parameter. Because you are expected to assign something to this output parameter now. And you can see my compiler error is that the out parameter 'book' must be assigned to before control leaves the current method. This is like leaving an uninitialized variable around. So that's the difference between ref and out. This code, if I were to comment out that line of code and change this back to a ref, that would be legal. But with the out keyword there, I am forced to initialize the output parameter.

Working with Value Types
We've spent most of this module talking about reference types because we've been working with a book, and a book is a reference type. I'll explain why in just a bit. But let's also look at value types. Let me write a test that we will start off with the name just Test1 again. But I want to say that variable x equals what happens when I invoke a method called get an integer. So IntelliSense was a little too helpful there. I just want to invoke a method GetInt. Let's create that method with Ctrl+. I'm going to change the return type here from object to int, and what I can do is simply return a 3. So now it's up to you to write an Assert.Equal. What do you think the value of x will be? Well, hopefully, you will say, and we'll have tried, that 3 is the expected value of x, and that would be true. It's pretty obvious what's happening here. I'm returning a 3 so the 3 has to go into x. In many ways, value types are easier to reason about. Whenever you're working with integers and floating point numbers and even DateTimes and Booleans in C#, or what we call value types, then what you see is what you get. When I return of value, the value of 3, then I'm taking this 3, which is produced by the method, and copying it into the memory location, which is reserved for this variable x. So x holds a value, and that value is 3. Previously I could also say that something like book1 holds a value, but in fact that value is a reference to some object that is somewhere else in memory. When we talk about value types like integers and Booleans and floating point numbers, the value is what you get. And now what I want you to try is try creating a method called SetInt, where you pass x along and try to do something to x. So I'm going to use Ctrl+. to say yes, generate a method for me called SetInt, and inside of this method let's just say x = 42. So now I want you to try to adjust the test to match what you expect to be in the variable x. Is it going to be a 3, or is it going to be a 42 because of the assignment that we made inside of this method?

Value Type Parameters
What you should have discovered is that you still see the value 3 inside of the variable x. And again, that's because C# always uses pass by value when you invoke a method. So when I invoke the method SetInt and pass along x, the value 3 is copied from the x variable into this variable that is a parameter to SetInt. And this variable could be named anything, by the way. The parameter names don't have to match the variable names that you use to pass into them. But the result is going to be the same because when I say z = 42, I'm copying 42 into the memory location for this parameter, the parameter z. And that's the only place where I can see that value now. The original variable x is unaffected. What I want you to do is pause the video and try to make this test pass by changing the SetInt method to pass by reference. You can try that now. So if I want to see the value 42 inside of x, I will have to pass by reference into this method. That gives this method a reference to my variable named x. And because this is passed by reference, I'm also going to have to use the ref keyword here. Again, the C# language wants to make it very explicit when you are not doing the default thing, which is to pass by value. So I'm passing x by reference. I know that this method can now change my x variable. And indeed, I should be able to run the test now and see that the value inside of here is 42. That would be correct.

Looking for Reference Types and Value Types
I told you at the beginning of a module that I would tell you how to differentiate between a reference type and a value type. How do you know when you're working with something that behaves like the integer, a simple value type? And how do you know and can be sure that you're working with a reference type, so a type like the Book class that we wrote? Well, the rules are very, very simple. Whenever you are working with something that has been defined by a class, then you are working with a reference type. So if I wrote a new type here inside of this file, a new type that I'm going to delete here in just a few seconds, so you don't have to follow along with this part, but if I create a new class, let's just create a class called Person, then I am defining a reference type. Any variable that is typed as person, the value inside of that variable will always be a pointer to some object in memory. On the other hand, in C#, another way to define a type is to define a struct, s‑t‑r‑u‑c‑t. Let me create a struct called Point. So I just want to give you a warning as I give you this description that in writing code for day to day business applications, you will typically, 99% of the time, be creating a class definition. Therefore, you'll be creating reference types. A struct is something that we will write that is more of a special type. It needs to behave like a value type, it's typically very small, just like an integer and a floating point number and a date time, they all require small amounts of memory. And because structs are small and behave differently, they can be a lot more efficient than reference types for certain scenarios. But you have to understand this advanced scenario to know when is it okay to write a struct type? Writing a struct is very much like writing a class in the sense that I can give a struct fields. I can give us struct methods, But there are some other special rules for structs that I'm not going to cover in this course, because, again, in day to day business programming, you just are not creating types that are structs. But there are types in the .NET framework that are struck‑based and, therefore, they are value types. And then the question is, if I'm using something from the .NET framework, how can I tell if it's going to be a reference type or value type? I need to understand the difference, because when I'm invoking a method and I'm passing along a parameter that is a reference type, I can make changes to fields inside of that object if I'm working with a reference type. So I just want to show you how you can tell how you can guarantee that you're working with a reference type or a value type. And if you go up to any type inside of Visual Studio or Visual Studio Code and place your cursor on that type identifier, so in this case, I'm going to select int, but this would also work if I place my cursor on book or float or double. When you place your cursor on that type and you press F12, you can go to what's known as a metadata view of that particular type. This metadata is a recreation of what that type definition would look like if you were to look at the actual source code for that type. So you can almost think of it as reverse engineering a particular type. But you're not going to find things like complete method definitions inside. But what you are going to find, that is important for this discussion, is you're going to see if an int is defined using a class or a struct, and in this case I can see int is a struct and therefore it's a value type. Now you might notice that the name of this struct is Int32, and that's because in the C# language, there are some special key words for some of these built in value type primitives. So things like integers and floating point numbers. They all have aliases in the C# language that are these lowercase identifiers. So yes and int, if we were to go back and look at that, is really the struct N32. And those two identifiers are really interchangeable. So I could also say that this method, SetInt, takes a parameter of type N32. That's the same as using the keyword int. Another good example of this is the double type that we've been using for floating point numbers. So if I place my cursor there and press F12, then I can see I'm really working with a struct that has the name Double where the D is uppercase. So I can use D with an uppercase or lowercase d. I can use either of those to declare a variable or a field of type double. Here's another example, in C # I can use the key word bool, all lower case. If I press F12 to look at the definition for bool, I can see it is another struct. So a boolean value is also a value type, and bool, b‑o‑o‑l, is just the C# keyword shortcut for the .NET type Boolean with an uppercase B. Now not all value types have a shortcut. So another value type in the .NET framework is DateTime. If I want to keep track of the date when something occurred, I can use a DateTime variable or a DateTime field to keep track of that value. And if I press F12, I can look and see that DateTime is a struct, therefore, it's a value type. And I can use this F12 trick whenever I want to look at the metadata for any type, even stuff that I've written or stuff that's in a NuGet package. So if I come down to the identifier Book and press F12, that's actually going to take me to Book.cs, but I can see that Book, that type, is built as a class, therefore, Book must be a reference type. Now there is one special case type in .NET. It's a special case because it is defined one way, but it behaves another way, and that special type is string. Let me declare a variable string, set it equal to an empty string. And I just do that because really, I just want to press F12 to go to the definition for string, or at least the metadata view, and you can see that string, which in .NET is technically uppercase S string is a class. Therefore, any time I'm working with a string in C#, string is always, always, always a reference type. Don't let anyone tell you anything different. However, string often behaves like a value type. So even though string is a reference type, quite often it behaves like a value type. What do I mean by that? Let me write some tests to demonstrate.

The Special Case of Strings in .NET
So what I want to do is write a test to understand how strings behave because this is something that trips a lot of people up, at least trips people up when they're starting with .NET. Let's create a new public void method called StringsBehaveLikeValueTypes. The thing about value types is that value types are really immutable. If I have the number 3, the number 3 is an integer. Therefore, it's a value type. I cannot really change that value. So how can I reassign the meaning of the integer value 3? I cannot. If I have a variable defined as an integer, well then I can change a variable. I can place the value 3 into the variable, and then I can overwrite the variable with a new value, 12. But that's not changing a specific value like 3. That's just changing the value that's in the variable from a 3 to a 12. And the reason I want to say that strings behave like value types is because in .NET strings are what we call immutable. I cannot change a string once I've created a string. So here's an example. Let's declare a variable typed a string so we know that that variable is going to contain a value, which is a reference. So it's a pointer to some string that is allocated in memory. And I'm going to invoke a method called MakeUppercase where I pass in a string, and I expect that method to make my string uppercase, so make it all uppercase letters. I'm going to use Ctrl+period to generate that method. So down here, let's say that we pass in something that I will name parameter. It's of type string. And it turns out it's very easy to make a string uppercase. There is a method called ToUpper that I can invoke. There's also ToLower and a couple other options. But I want to make this ToUpper, which I saw in the description makes an uppercase string. And now I want to assert that my name is equal to an expected value of Scott. That's what I believe the method should do at least because why is this any different than, let's say, passing along a book to some method that sets a name? So I pass book1 to the method SetName, and it can change the name of the book. So down here, all I want to do is pass a parameter of type string to a method to make that string uppercase. Why wouldn't they work the same? I mean, they are both reference types, right? But I will find that this test fails. So if I come out to the command line and run dotnet test, it will take a second, and I should see that I did expect an uppercase SCOTT. But the actual result I got back was still Scott with only an initial uppercase S, and that's because this method ToUpper does not change the string that you invoked the method on. Notice the description there says returns a copy of the string converted to uppercase. But the key part there is it returns a copy. So there's many methods available on a string object. There's ToUpper and ToLower and all sorts of things that you can do to a string. But none of those methods will ever change the underlying string. They will all return a new string that you then have to either return or save into a variable. So if I make this method return parameter.ToUpper, now at least I can return the new string that I've made. Of course, I will have to change the return type here to be of type string. And now I would also have to say that name = MakeUppercase, and I expect that method to return to me the string that is now uppercase. And just to make that clear, let me create another variable upper because my original name variable should always be Scott. That string will never change no matter how many times I invoke ToUpper or ToLower on it. But this new variable will point to my new string that is all uppercase. So if I save the file, come out, and run dotnet test, we should see in a second some green text. Yes, the test run is successful. And now we know that yes, strings are reference types. So when I invoke MakeUppercase, I'm passing my name variable by value, but the value inside of that variable is a reference. So I have a pointer to a string. But even though I have a pointer to a string, there's no way I can actually modify the underlying string because strings are immutable.

Taking Advantage of Garbage Collection
Now when we talk about memory and we talk about instantiating objects, anyone who's new to .NET might have a question. And that question is, if I can construct objects and bring them to life and instantiate classes, then am I ever responsible for cleaning those objects up? Do I ever have to tell the .NET runtime when I'm finished using an object and tell the runtime to delete that object or free up the memory? And the answer is, no. One of the services that the .NET runtime provides is a garbage collector. So the .NET runtime can keep track of all the objects that you have allocated and created, and it also keeps track of and knows about all the variables you've created and all the fields that you have inside of objects that point to other objects that are in memory. And the .NET runtime knows when there's an object in memory, it knows when there's no variables and no fields that are pointing to or using that object. And it knows when that happens, when nothing is using that object, it can run a garbage collection and clean up and deallocate that object. That frees up memory so your program doesn't exhaust memory. Yes, it is possible to exhaust memory and use up all available memory if you just keep allocating things and keeping references to things that are in memory. But the typical application will instantiate an object, use it for a little bit, and then it goes away because our variable just no longer references that object or our variable goes out of scope. So, for example, book1 and book2, they're both referencing the same object, but at the end of this method, there's nothing left that will reference the object created by GetBook and assigned into this book1 and book2 variable. By the end of this method, the garbage collector in the .NET runtime can detect that there's nothing referring to that object. It can clean the object up, It can collect garbage, and it can make memory available for other tests that are in this project.

Summary
In this module, we learned a few different things. We learned there's two categories of types in .NET. There's reference types defined by classes, and there's value types defined by structs. We also learned when we pass parameters to methods, we always pass those parameters by value. We always pass those parameters by value. And perhaps most importantly, we learned that we can use unit tests to explore and understand how C# behaves and how .NET behaves.

Controlling the Flow of Execution
Introduction
Hi, this is Scott, and in this module, we are going to go back to adding features to the grade book and spending time with the C# language to understand some new syntax features and see how the language works. I specifically want to spend time with control flow in this module, so I want to look at the features of C# that let us branch the if statement that we've already seen, but there's also looping, jumping, switching, and returning. We'll see examples of all of these, as well as how to throw and catch exceptions to either create or manage those error conditions that occur in our software.

Branching with if Statements
Let's start by talking about branching in C#. The usual flow of execution in a C# application is to start with a line of code like line 10 here and then just keep executing and moving to the next line of code until we get to the end of the program. But along the way there might be statements, statements like looping statements, the foreach statement, that alter this flow, and we can also have branching statements where we branch to a different line of code, depending on some condition. And we've already seen one branching statement in this course. Earlier in the course, we used the if statement. So with the if statement, I can check some condition and branch the flow of execution. So I go to one piece of code or a different piece of code, and let's imagine that inside of this AddGrade method, I wanted to make sure that the grade is actually greater than or equal to 0 or less than or equal to 100. I can express that logic inside of an if statement and only add a grade to the book if the grade matches those conditions. So, first of all, if the grade is less than or equal to 100, that's one condition I want to use, and I could put grades.Add(grade) inside of the curly braces here. So we only execute this line of code if we branch inside of this block because that condition returns true. So if grade is less than or equal to 100, we'll branch in here, execute grades.Add(grade). But I also want to check to make sure the grade is greater than or equal to 0. So if someone gives me a negative number, I don't want to add that to the grades. One way to express that logic is to nest one if statement inside of another if statement. What I generally prefer over a nested if statement, when possible, is to instead use some Boolean operators to combine those two logical checks into one expression. So I can say, if grade is less than or equal to 100 and, with a double ampersand, grade is greater than or equal to 0. So this logic is the same as what we had, but now instead of two if statements I have a single if statement. Some of the other Boolean operators that you will see include or, and this particular line wouldn't make any sense to say grade is less than or equal to 100 or grade is greater than or equal to 0. Because what can happen, if someone passes in a negative grade, like ‑5, the way C# works, that if statement we will check first, is the grade less than or equal to 100, that returns true. Therefore, the way the C# program executes is we'll say yes, this statement is successful, let's go and branch inside of the block and add the grade because in a C# program, if the left‑hand side of an or expression returns true, we never need to evaluate the right‑hand side because we're saying if this is true or if the right‑hand side is true, but we only need to check the right‑hand side if the left‑hand side is false. That's known as short circuiting in some languages, and it's not true with the and operator because now we have to make sure that both sides of this expression evaluate to true. The grade has to be less than or equal to 100 and the grade has to be greater than or equal to 0. So if we pass in a ‑5, sure, the left‑hand side will return true, but we also have to check the condition on the right‑hand side to make sure that both evaluate to true. And by the way, if you want to check to see if something is exactly equal, which is always dangerous with floating point numbers, as we discovered earlier in the course, I could say if grade equals, let's say a 90.0, so double equal symbols, and that differentiates this equality operator to compare if two things are equal from an assignment operator, which is just a single equal sign. So down here I am saying instantiate a new instance of the Statistics class and assign that value into the result variable, whereas up here with the double equals I'm saying, please compare grade against the value 90.0 to see if they are equal. And don't worry, if you forget to use a double equal sign, you'll typically create some sort of error. In this case, what the C# compiler is saying is you're assigning this value 90 to grade, and so you're basically saying if 90, and 90 is not a Boolean value, it's not a true, it's not a false. We're not going to know what to do with that at runtime. So you have to write an expression that produces a Boolean value, true or false. And to do that, I need Boolean logic operators like equals and greater than and less than and the and operator and the or operator and so forth. Now something we'll come back and revisit later in this model is that we should really tell these or something if we're not going to add a grade to the grade book. We should have some sort of message that lets them know something went wrong. For right now, I'm just going to add a WriteLine that says Invalid value, and later I will come back and show you a better way to do this. Now, if you want to take an optional challenge at this point, write a unit test that will prove that the logic inside of AddGrade is working correctly. In other words, inside of a new unit test that you create, instantiate a book and then try to add a grade of 105.

Looping with for, foreach, do, and while
There are a few different looping constructs that you can use with the C# language. One looping statement that we've used already is the foreach loop. So this is saying, for each grade that you find in the grades collection, and now the code that is inside of the block here will execute once for each grade that we find, and the value of each grade will be passed in as this grade variable. So that's one way to write the loop. But let me show you a few others. And what's interesting about this exercise is you can try this on your own and make sure that the unit tests are passing each time you change the style or the loop that we're using, and the unit tests can prove that the program is still working correctly, even though we've made some changes to the code. That's one of the beautiful things about having units test in place. But, first, let's look at the do‑while loop. So with the do‑while loop, I use the do keyword. That comes above my opening curly brace, and after the closing curly brace, I express a condition, and that condition will tell the runtime, should it continue to do this loop? So with all these other looping statements that we're going to use, we're no longer going to have the grade just handed to us by the looping statement. Instead, we're going to need to keep track of which index we're looking at in the series of grades, the list of grades that's available, and we're going to have to peek into that list to pull a grade out. So let me declare a variable. Let's call it index. Some people would just call it i, but I'll call it index. And index represents where we are in looping through the entire list of grades. So I always want the ability to say grade[index] to, let's say, give me the first grade on the first time through this loop, and I'll use that once more here to add up the average. And now I don't want to go to grade. What I want to do is go to grades. So I want to go to the list of grades. And here's where I want you to pause the video and jump in and see if you can complete this. So we need to do two things. First of all, we need to write a condition inside of the while statement here that will tell the runtime when to terminate this loop. So when have we examined all of the floating point numbers that are in that List<double>? And the other thing we're going to need to do is maintain our index. So the first time through our loop, the index is 0, and we will be looking at the first grade. But the second time I come through this loop, I want to look at the second grade. So see if you can add those two pieces of information to the code and make the unit test pass, and then come right back. Here's how I'm going to solve the problem. Down here before we check our while condition, I'm going to say add 1 to the index. So I can do that by using the += operator, index += 1. That will ensure that we're always bumping up the index by 1 and looking at the next grade the next time we come through this loop. But I can also do that by saying index ++. That's a fancy way of saying add 1 to the index with the ++ operator. These days, I almost prefer to see += 1 because it's very clear and evident what is happening there. And now I need to add a condition. I need to tell the runtime when to stop looping, and a good condition might be to say while(index < grades.Count). And, yes, I want to use < because, remember, if I have 4 grades in my grade book, the count of grades will be 4, but the last item in that list will have an index of 3. So I want index < grades.Count. And this is a good place where you can have unit tests to make sure that you're not missing a grade or that you're not off by one or that you haven't allowed the loop to try to index into the grades collection and reach something that doesn't exist inside of there. And now I just need to terminate my statement with a semicolon, and that's the do‑while loop. Now one thing to be careful of with a do‑while loop is that the loop is always going to execute at least once. We're always going to come in and start executing this block of code at least once because we do not check the condition for looping until we reach the end of that block of code. So we do this code while some condition is true. And that means if I have a list of grades that is empty, this code can fail because I will be trying to index into the grades list with an index that doesn't exist, index 0. And that's where I would either need to surround this with an if check and only execute this loop if grades.Count > 0, or I can change this to a while loop. So with a while loop, I place the condition at the top of the loop instead of the bottom of the loop. And let me just cut out this expression down here, cut this out and take it to the top and say while(index < grades.Count). So now before we start this loop for the first time, we're first going to check this condition, and in the event that grades.Count is 0, because there are no grades in the List<double>, I will not execute any of the code inside of the loop. That's the primary difference between do‑while and while. Do‑while will always execute at least once. And now let's look at one more type of loop where I do not need to declare this index variable. At least I don't need to declare it on a separate line because now what we're going to write is a for loop. Now with a for loop, I don't need the closing semicolon. I'm going to remove that. But I do need to write a statement that consists of a couple different pieces. Depending on your experience with different programming languages, this might look very strange or it might look very familiar. But when I write a for loop, I can first write an initialization expression. So the initialization expression gives me the opportunity to declare a variable or initialize a variable or declare and initialize a variable that I'm going to be using through the rest of the loop. So this is where I can now say var index =0. So I've declared a variable index that's going to be of type int, and its initial value is going to be a 0. Then I use a semicolon and I write the second piece of my for statement. The second piece is going to be the condition to check before the runtime enters the loop. So this is the condition I write to say I only want to execute the code inside of here if this index meets some criteria where it's actually going to be able to pull out a grade. So I can say if index < grades.Count, that's going to be my condition. So we saw that condition before with the while loop. But you can think of this for statement as sort of a fancier while loop that concatenates a few things together inside of the for statement itself. So here's my variable declaration. Here's the condition that I checked. And then, finally, I can write a third expression here, which is the operation that I want to perform after each iteration of the loop. So after we finish the loop each time, what I want to do is add 1 to the index variable, and that means down here at line 39, I can remove this line because we're performing that operation up here. So what we have now is a for loop that will behave just like the foreach loop that we had previously. It's just using a different syntax where we're being a little more explicit about how we're accessing each grade in the grade collection. So which of these looping statements should you use? I generally use the foreach statement whenever I can. I think it's the clearest, most concise form of looping. I only use a for statement like this when I need some low‑level control, or I have some collection that just doesn't support the foreach statement. We're going to talk a little bit later in the course about some of the magic that actually occurs behind the foreach statement. And then, occasionally, I might use a do‑while loop when I have a loop that I am sure I want to execute the code inside at least once. But, otherwise, the foreach looping statement is typically what I want to use.

Jumping with break and continue
Let's talk about the jumping statements in C#. Jumping statements allow me to jump over code to reach some other line of code that's in a method. And, in general, you have to be very careful with jumping statements because sometimes it's hard to follow the logic of a method that uses jumping statements, but let me show you two common jumping statements. The first one is the break statement. So let's say I'm inside of this for loop and I decide that if I see some specific grade as I'm looking through the entire list of grades, if I see some specific grade value, I want to halt calculations at that point. So if I see grades sub i or sub index, if I see a specific value like 42.1, so I'm just making up a scenario and writing arbitrary code here, but if I see that value, what I want to do is skip over the next three lines of code and not only skip over this code, but stop Iterating through this loop. So even if my index +1 is still going to be less than grades.Count, I want to stop the loop early. If that's the case, that's where I can use the break statement You can think of break as the ability to break out of this loop. So we're going to not only skip these lines of code, we're going to break out of the loop entirely and end up here on line 45, which would then not compute the correct average, by the way, or there's a possibility it's not going to compute the correct average because we have not added up all the grades. But we're still dividing by the count of all grades, so the average is going to be too low, but this is what the break statement will do. On the other hand, imagine we see this value 42.1, and it's just that one singular value that we do not want to include in the calculations. In other words, I want to skip these three lines of code, but I want to keep looping if the index is still inside of the count of grades. If that's the case, instead of a break statement, I can use a statement, continue, which is a way of telling the runtime continue with this loop. So skip over these lines of code and just go ahead and continue with the next iteration. You should check the condition, and you should increment index by 1, but I'm ready to go the next time through the loop. The third jumping statement, which I almost hesitate to mention because in 20 years of C# development, I've only seen it used once, and that was not a business application, is the goto statement. So with goto, I can say goto and then some arbitrary label that I pick, and the label would be an identifier that I apply to some line of code. So I could say here that I want the label done applied on line 45, or even to make things more interesting, here on line 47. And this is a way of saying, if we see the value 42.1, just go to done, just jump to line 48 and return a result, even though we haven't calculated the average and we haven't made it the whole way through the loop. That's what goto will do, but no one really uses goto these days, so maybe you should pretend that you didn't even see that.

Switching with the switch Statement
Now I want to talk about the switch statement in C#. So back when I was growing up, we had the concept in my school of a letter grade. A letter grade would be a grade that you received as a letter instead of a number. So the letter grades were A, B, C, D, and F. A was the best grade, F was the worst grade, and typically considered failing, so it might be that you failed a test or failed a homework assignment. And what would happen if I wanted to give users the ability to add a letter grade to the grade book? In that case, I might create a method, AddLetterGrade, that instead of taking a floating point number will take a single character, so not a string of characters, but there is a type in C# that allows you to take a single character. That's the char type, or what some people will call the car type c‑h‑a‑r, that's a single character. I will name this parameter letter, and if we use the F12 trick to see if character is a value type or a reference type, we will see that character is defined by a struct, so it is a value type. And now, you might wonder why I added a new method here, or a method with a different name than AddGrade. We'll come back and talk about that a little bit later in the course. There is another way to do this so that I can have AddGrade that takes a double and AddGrade that takes a letter, but I just want to defer that discussion for now. But what we have to do inside of this method is map from a character into a number, because ultimately we're storing numbers. So I can come up with an arbitrary list of saying, well, the letter grade A maps to the number 90 and the letter grade B maps to the number 80, so it would be a grade of 80, and I could express that logic using if statements. So I could say if letter equals an uppercase A, then what I want to do is invoke my AddGrade method and pass along a 90. Otherwise, what do I want to do? Well, I want to point out that there is an else if statement in C#. It works just like the if else statement, except instead of automatically executing the else when the if condition up here fails, we first have to pass another condition before we execute the block of code defined by this else if. So I could say else if letter equals an uppercase B, then we add the grade 80. And I could continue doing this, but there's another way to express this logic, and that's using the switch statement in C#. Here's how the switch statement works. I use the keyword switch and then I provide the variable that the switch statement is going to operate on. So I want to switch based on the value that is in the variable or the parameter named letter. And then I can provide different cases for the switch. This is where I can write code so that at runtime my program will compare the letter value to the value of some constant that I express here. So the way I do this is with a case statement. So I'm essentially saying, in the case where the letter is equal to an uppercase A, then I use a colon and I want to execute the following code. I do not need to use curly braces here to denote the block of code that I want to execute, I can just start writing code here like AddGrade and I can have multiple lines of code, but this would add the number grade 90 when the letter grade is an A, and then I can have my next case, which would be if the letter grade is a B. And notice that I am using single quotes here to express a character. If I were to use double quotes instead of single quotes, then the C# compiler would treat my constant as a string. That's not what I want. I want a constant that is itself a character, and for this I can say I want to add the grade 80. Now before I continue, I want to point out that I do have a compiler error here. The error is that control cannot fall through from one case label to another. What the C# compiler is saying is that I need to see something else inside of this case statement that will explicitly control the flow, because in some other languages that also have switch statements, you could write a case that has some code, and then if you didn't explicitly control the flow of execution, the runtime would just keep going down to the next line of code and execute that line of code, so you could have situations where you pass in the letter grade A and that would add the Grade 90 and then also add the grade 80 because that's the next line of code. The C# compiler wants us to explicitly forbid that, and one way to do that, the most common way to do that, is to use a break statement. We saw the break statement earlier inside of a loop, and this break statement does the same thing. It's going to break out of the switch, so the next line of code that is executed after I add a grade of 90 when the letter grade is an A would be the line of code that comes after the switch statement, and if there is none then the method is finished executing. So let's add our break statement here. I can continue this exercise and say case when we have a C. And notice these are all constant values, so A, B, and C these are all hard‑coded values; they're not dynamic values being computed at runtime. In this case, I want to add the grade 70 and then break. I could also have a case for the letter D, but then what happens if letter does not match any of these cases. Well, that's something that is legal and can happen, and in that situation I would not execute any of the code that is inside of here. But if I want to have a case that will execute when none of the other cases do execute, then I can use the keyword default and say, here's what to do by default. By default what we're going to do is add a grade of 0. So that would happen currently if I receive a letter that is anything other than an uppercase A, B or C. So if someone passes an uppercase F or lowercase f or the letter Z, we will add the grade 0, and then we will break out of the switch statement. And this is an example of the simple switch statement that has been around in the C# language since the very beginning. Next, I want to introduce you to a slightly more sophisticated switch statement.

Pattern Matching with switch
Starting in C# version 7, the switch statement became a lot more powerful. In C# version 7, Microsoft gave the switch statement the ability to do what we call pattern matching. Now typically, pattern matching is used to match some variable against a certain type. So if I want to find out if some object at runtime is really a book, or a console, or an employee, or an invoice, that's typically the type of scenario that you use with pattern matching. But the features that they added to the switch statement also allow me to do some additional things. So here's what I want to do, inside of GetStatistics, I not only want to compute the average grade, I also went to compute the letter grade for that average. So when I was in school, any grade that was 90 or greater would have a letter grade of A. An average grade of 80 or greater would be a B, 70 or greater was a C, 60 or greater was a D, and anything below 60 was an F, or failing. And so what I want to do is come into Statistics, and in addition to computing the average, the high, and the low, I want to create another field, a field of type char, and call it Letter. We're going to compute the letter grade. And over in program.cs, in addition to writing out the average, and the high grade, and the low grade, I also want to WriteLine the following string, which is the letter is, and then used the expression stats.Letter. So we will be able to see the letter grade that is computed. So given the rules that I just gave you, what I want to do here after we compute result.Average is do a switch on result.Average. And I do want to point out this is only one way to achieve this in C#, there's various ways you could do this, including just writing if/else statements, and to some people, the if/else statements might be cleaner code, might be easier to read. But let's try this with a switch statement. What I want to do is say case, and now I'm going to use some of the enhanced powers of the switch statement, which allow me to declare a variable in my case statement. So I can say var d, and what will happen is I will now have a variable available inside of this case statement. The variable name will be d, and at runtime, the variable d will receive the value that is in result.Average. So inside of this case statement, I effectively have a variable named d that will contain the average grade. And now I can use the next powerful capability that was added to the switch statement, which is the ability to use a when keyword. The when keyword allows me to provide a condition that will be evaluated at runtime, and only if that condition returns true will I execute the code that is associated with this case statement. So previously in our switch statement, we just had to use these constant values. Now I can take a variable and essentially say when d is greater than or equal to a 90.0. Now I still use the colon, and I can write a block of code that references the variable d. So in this case, I could say that the result.Letter should equal assigned to that the character A. And once again, I will use a break statement. Now, let me copy these few lines of code. So I can say case d, and when d is greater than or equal to 80, let's use a B. I'm going to paste one more time when we are greater than or equal to 70, that letter grade should be a C, when we are greater than or equal to 60, that's a letter grade of D, which is getting bad, but it's not quite as bad as getting an F, and we will just make that the default case. So this structure of the switch statement is the same. In fact, it is the same switch statement that we saw previously. There's just some additional features in C# version 7 that allow me to declare variables, allow me to use this when condition, and for advanced users, the switch statement does pattern matching, which effectively allows me to do some type matches, type comparisons, and we'll learn more about how that can be useful a little later in the course. What I would suggest you do before you even implement all this code, maybe you've been following along and you've already typed all this, is to go into your test and assert that you are computing the correct letter grade, at least for this one simple scenario that we have here. So what I would do is assert that given an average grade of 85.6, that should be a letter grade of B, so I would rate and assert that result.Letter is in fact the letter B. Let's save all that, come out to the command line, do a dotnet test, and I'm hoping to see green text scroll by, which does happen, that test run was successful, I know I computed the correct grade.

Challenge: Taking User Input from the Console
Now it's time for a challenge. What I want you to do is make changes to this program so that instead of hard‑coding these grades into the program, you're actually taking grades from the console and you're typing grades into the program at runtime. So when I run this program, I want the program to prompt me and say, please enter a grade. If I enter a number, like 72, that number is added to the book, and I want you to set up a loop so that I can enter as many numbers as I want. Only if I enter the letter Q will you stop accepting grades and you'll go ahead and compute statistics and then show those statistics on the console. So effectively you need to have a loop right here that will continue asking me to enter a grade on the console, and you'll take that grade and enter it into the grade book. I'm going to give you two tips, two things you need to know. First of all, if you want someone to type to enter something into this program, what you can use is a Console.ReadLine, So WriteLine puts something out into the console, ReadLine allows me to type with the keyboard and press the Enter key to give you input. So if I type 7, 2, and Enter, input will be a string with the character 7 and 2 inside. In order to take that string and put it into a double‑precision floating point number, you're going to need to parse that string. The easiest way to do that is to use a static method that is available on the double type, and that static method is the parse method. So I can say, please parse this input so that if I enter 72.3, that will become the number 72.3, and I'll have that available in this grade variable, and then I can insert it into the book. So those two lines of code you should find helpful, but what you need to do is set up the loop so that you take input from the user. I'll show you my solution in the next clip.

One Solution
There's various ways that I could implement the code to fulfill the requirements that I just described. So what I'm going to show you is just one possible working approach. First of all, I know I need to loop until I reach some specific condition. I need to loop until the user enters a lowercase q. So I'm going to go ahead and declare a variable named done and set that equal to false. So this variable will be my flag. When do I finish looping? I finish looping and stop looping when done is true. So I'm going to write a while loop that says while I am not done. So the exclamation point in C# is the Boolean operator that flips this expression, so if done is true, not done is false. If done is false, not done is true. So while I am not done, please execute the following code, and what we will do is now take our input. So allow the user to enter a grade, but how does the user know they're entering a grade? Well, it might be nice to first do a Console.WriteLine that says Enter a grade or enter the character q to quit. Now the user has some idea of what they need to do. The next thing I could do then is parse that input into a floating point number. So let me copy that code and paste it up here. I want to parse the input into a double, well what happens if the user just entered a q? Well, I can tell you this parse is going to fail. There's no way to parse a q into a double. This code will fail, so I really want to get out of here if the user did enter a letter q. So we can use one of the jumping statements that we looked at earlier. I can say if input is equal to the character q, but that's not going to be quite right because here the C# compiler detects that input is actually of type string because Console.ReadLine returns a string, it returns a full collection of characters, and I'm trying to compare that to a single character, which is the lowercase q. The easiest thing to do here is, again, several ways to solve that problem, but the easiest thing to do is just to make q a string also. So I'm saying if input is equal to a string, which is the letter q, well then we are complete. So I could set my done flag equal to true and then do a continue, and what that will do is skip over the parsing and jump right back up here to the top of the loop, see that the done flag is now true, so we would exit the loop and come down to book.GetStatistics, and you might say, well, why instead of going to all that work, why don't you just say break and break out of this loop? And that's perfectly acceptable too. In fact, if I use the break statement, I don't have to have a done variable. I can get rid of that, and I can just write something that looks like an infinite loop. I can just say while true. So execute this loop forever, except we do have a break statement in here that will allow us to break out of here. So now we've handled that situation. We're parsing the input into a double. Now the only thing left is to walk up to the book and tell it to add this grade that we just parsed and then to try it again. Let me save all the files, including Program.cs. Let's come out to the Command Prompt, and what I want to do is dotnet run a specific project. So I want to dotnet run and specify the project that is in the src folder, it is my GradeBook project, and it is GradeBook.csproj. I hope I get a prompt to enter a grade or q to quit. That's looking good, so let's enter the grade 95, and then let's enter the grade 85, and then let's try a 75, and then I'm going to try a q to quit. And looking at the results that the lowest grade is 75 and the highest grade is 95, and the average is 85, all those numbers seem very reasonable and seem correct. The letter grade if a B, that is correct, or an average grade of 85, so it looks like the program is working. And hopefully you came up with something similar. But let's go one step further. What happens if the user enters a grade that is just a series of characters? So the cat walks across the keyboard and presses Enter, and I have a fatal crash. I have an Unhandled Exception, a System.FormatException. Earlier in the course, we saw a NullReferenceException, so this is a different type of exception. But the result is still the same, our program has come to a crashing halt, and this is an error condition that we really should handle because we should expect a user to give us invalid input. In fact, believing that your user will always give you good input is what gets the software industry into a lot of trouble. That leads to a lot of these security vulnerabilities that we see in the world, so we should expect something like a format exception to happen. How do we deal with a situation to keep the program alive so it can continue running?

Throwing Exceptions
Before I show you how to deal with exceptions so that the program can keep running even when the user gives me bad data, I first want to show you how you can produce an exception. So let's go back to the example inside of the book where we have the method AddGrade, and we want to make sure that the grade being added is less than or equal to 100 and greater than or equal to 0. Currently, if that condition is true, we go ahead and add the grade. Otherwise, we do not add the grade, and all we do is write something to the console that says Invalid value. Sometimes that's the right approach for software. We can expect that we will occasionally receive an invalid value for a grade, and perhaps we just want to provide a little bit of feedback, a little diagnostic message that says, that value we just received, that was invalid. But other times we might want to create our own exception because that invalid value that we receive should never happen. And we want to make it very clear to the caller that they have done something erroneous. They have tried to add a value that cannot exist in the grade book due to the business rules, and we want to make sure they know about that. We don't just want to write out something to the console that the user will see; we want to create an error condition. And the way to create an error condition is to throw an exception. So there is a keyword in the C# language which is throw, and the only types of objects that you can throw are exception objects. So I want to throw a brand‑new exception that I'm going to create. And you can see in the IntelliSense window here, there's actually a number of built‑in exceptions in the .NET framework. So just like .NET provides classes to represent doubles and strings and consoles, .NET also provides some built‑in classes that represent exceptions. Now quite often in a larger system, you want to build your own custom exceptions, but that's more of an advanced topic. I'm going to show you how to work with some built‑in exceptions. So any time you receive a parameter value to a method and you believe that parameter value is invalid, there's already a built‑in exception that describes that scenario, and that is the ArgumentException. So if I throw a new ArgumentException, I'm saying there is something wrong with one of the arguments to this method. And typically, what you do with an ArgumentException is use a constructor that allows me to pass along a description with some additional information. So I can add a string to this to say something like, the grade is invalid or perhaps Invalid grade. This is very useful if there are multiple arguments to this method, so if I also took some sort of string parameter, then I want to let the caller know that the second parameter was okay, but it's the grade that was a problem. And so this is typically your parameter name. And instead of hardcoding that here, there is a keyword in C#, which is the nameof keyword. What I can do is pass in a symbol, which can be a method name, a field name, a parameter name, pretty much any identifier that exists in scope here, and what the nameof operator will do is return the string representation of that symbol. So in this case, I will still have the string grade here, but now if I ever change the name of this parameter, I will be forced to change that name here also, so I can be sure that I'm producing the correct name. So now if someone gives me an invalid grade, I will throw a new ArgumentException. And what does that look like currently? If I dotnet run this project and enter a grade of 90, that works perfectly. If I enter a grade of 105, now instead of having a FormatException crash my program, I have an ArgumentException crash my program. The reason this exception crashes my program is kind of implied by this keyword throw. What we're doing is throwing this exception. And someone else has to catch this exception if they want to handle this error condition. Otherwise, the exception is going to crash the program. And technically, what happens behind the scenes when I throw a new ArgumentException is the runtime starts looking for a piece of code that can catch this particular exception. And it's first going to look in this method after I throw this exception. And if it doesn't find something that can catch that exception in this method, it's going to go to the code that called this method. So up inside of Program.cs, when I say book.AddGrade, I called that method. The runtime will look for something to catch that error here. It doesn't find anything. And when the runtime doesn't find any piece of code that will catch that exception, that's what can crash my software. So next, let's look at how we can catch, or handle, this error.

Catching Exceptions
If I expect a particular piece of code to throw an exception under some conditions, and I want to handle that error condition, that is, I want to catch that exception, I can use what's known as a try catch statement in C#. Here's how a try catch statement works. First of all, there's the keyword try, which is a pretty descriptive keyword, because what I'm asking to do is to try the following lines of code. So, both of these lines of code are inside of my try statement. That means I want to try to execute these, but I know that they might throw an exception, so I'm going to now use the catch keyword to try to catch and process those exceptions. And again, just to review how exceptions work, if I invoke double.Parse and I pass in an input that is just gibberish, just a string where the cat walked across the keyboard, double.Parse will throw a FormatException. When double.Parse throws a FormatException, we skip over all the code that I'm trying here, so we skip over book.AddGrade. What the runtime is looking for is the catch statement that is closest to where the exception was thrown, and currently this would be the catch statement that is the closest to where the exception is thrown inside of double.Parse. Inside of this catch statement, what I can do is essentially declare a variable, so I want to declare a variable. First of all, let me show you I can declare a variable of type Exception, let's call that ex, and what this will allow me to do is catch any type of exception. So we haven't talked about inheritance yet in C#, we'll get to that later, but essentially all the different types of exceptions that you can have, and you saw some on that list, like the argument exception, and you've seen the null reference exception, and you've seen the format exception, those are all different types of exceptions, but they can all be caught by using a catch statement that says it wants to catch essentially every exception type. And inside of here, if I catch that exception, I can say, well, let's just Console.WriteLine the ex.Message, and then continue on, because if I catch the exception, the runtime is not going to crash or terminate my software, we can just catch the exception and go back to the beginning of a loop and try again. Let's try this real quick. I'll save that file, come out to the Command Prompt, let's do a dotnet run. I will first enter a grade of 86 just to prove we can still get something into the book, and then I'll enter a grade of 106, that's an invalid grade so you can see that message appear, and behind the scenes we did throw an exception, but we also caught that exception, so we can continue looping. Now what happens when I enter gibberish? Well, now I display the exception message, which is input string was not in a correct format, but again, we continue looping so I can enter another grade and I can press q to quit, and now my program is not crashing. Sometimes crashing is really what you want to do because if you catch an exception, well, something exceptional has happened. There's been some sort of error that has happened. And in some situations, that error might mean that your software cannot continue. Perhaps you were trying to write something into a database, or perhaps you were trying to write something into a file, and the file system is full, or the database doesn't exist, or the network is down. Every application is different, but there are some applications where you should just give up and say, sorry, I cannot continue. If that's the case, it's still possible to catch the exception to provide an error message to the user. But if I wanted to continue to propagate the error, what I can do inside of my catch is add a throw statement, and what this will do is re‑throw the current exception. So if double.Parse throws an exception, I'm going to catch that exception, and I'm going to write out the message, but then I'm going to re‑throw the exception so someone else either has to catch that exception or my program's going to terminate. Now, I do want to point out that catching exception is not the right thing to do in all circumstances. Sometimes you want to catch a specific exception type, because if I use a catch block with Exception, this will catch anything that goes wrong in double.Parse or book.AddGrade, and really, I don't know what errors might occur inside of double.Parse and book.AddGrade. I might run into memory errors if I try to add too many grades, I don't know. So in many cases, what you want to do is write a catch statement that will only catch the specific types of exceptions that you know you can deal with. For example, if I catch an ArgumentException ex, well, I know AddGrade can throw an ArgumentException if the grade is out of range, and I realize that's an error, but I can safely catch that error and then continue on, so I don't want to re‑throw that particular exception. I just want to display a message to the user and then continue through the loop, enter another grade. So now I'm catching the ArgumentException, but what about the FormatException that double.Parse can throw if I enter in gibberish? Well, you can stack these catch statements, so I can say I want to catch ArgumentException and execute this logic, and I want to catch a FormatException, I will also name that ex. And I could here, if I wanted to, also WriteLine ex.Message to let the user know that they did not format their double correctly. So, for many C# developers, this is the proper way to write a try catch statement around these two particular lines of code because these are the two errors I know about, these are the two errors I know I can handle and safely recover from because I can just discard the value and allow the user to enter a new grade and we'll try again. And then one more keyword that you can use with a try catch statement, you can also add what's known as a finally block. A finally block is useful if there's a piece of code that you always, always, always want to execute. You want to execute the code right here when the code inside of your try block executes successfully, but you also want to execute the code inside of the finally block when something here throws an exception. So let's say double.Parse throws an exception. That will skip over AddGrade, and if it's a FormatException, we will jump to this block of code and execute this line of code, and then finally, we will also execute whatever code is inside of this finally block, and I can have multiple lines of code. And this allows me to execute this Console.WriteLine regardless of the chaos that might be happening above me. And this finally block can be very useful if you're in a situation where you need to make sure that you close a file or close a network socket or properly clean things up, even when there has been an exception.

Summary
In this module, we saw if statements, we saw different types of looping statements, we saw the switch statement, and we saw how to throw and catch exceptions. And now it's time to turn our attention back to types in C#. What I want to do is show you how to add some additional members to a type like a class, as well as some new keywords that you can use to define types for .NET.

Building Types
Introduction
Hi, this is Scott, and in this module we are going to look at additional members that we can add to type definitions. So in addition to fields and methods, there's other useful members that we can add to a class definition, including properties, overloaded methods, and events.

Overloading Methods
So far in the course, we have learned that classes allow us to define new types for .NET, new reference types to be exact. And all of the methods and the fields that I add to a type are members of that type, members of the class. And when I added this method AddLetterGrade to the class, I made sure that I used a different name than the method below this, which is AddGrade. And I did that because, in general, you could not have multiple members using the same name inside of a type definition. However, there is a feature of the C# language that allows you to have multiple methods using the same name inside of a type. This feature is known as method overloading. I didn't want to explain method overloading earlier in the course, so I saved that discussion for now. What I could have done when I added this method to the book class is just named the method AddGrade because the C# compiler, when it is looking at method members, it is looking at more than just the method name. It is looking at what we call the method signature. The method signature consists of the method name. Yes, that's part of it. But the signature also consists of the parameter types and the number of parameters to that method. So a method named AddGrade that takes a character has a different signature than the method AddGrade that takes a double. Note that I am not including the return type in the method signature. The return type is not part of the method signature. So let me temporarily take this AddGrade method and copy and paste it here. I'm going to delete this code in just a bit. Let's change the return type to string, and let's temporarily return just an empty string. And you'll notice I have a compiler error appearing that this type book already defines a member called AddGrade with the same parameter type. So the C# compiler does not look at the return type when it's trying to determine if two methods are essentially unique enough to both live in the same type. The return type doesn't count. But it is possible for me to have AddGrade that takes a character parameter and, let's say, an integer parameter that we do something with. Now this AddGrade is different from the AddGrade that takes a character, and it's different from the AddGrade that takes a double because it has a different parameter type and a different number of parameters. So that is all part of the signature. Note that the parameter names do not matter. It's simply the number of parameters and this parameter type. So character is different from int, and character is different from double. So I'm going to delete this version of AddGrade, but we still have AddGrade that takes a character and AddGrade that takes a double. And if you think about it, this makes sense because the C# compiler can generally tell which method we are invoking when we're calling that method. So over here in the program, down here when I do book.AddGrade and I pass in a double, well the C# compiler knows we're going to invoke the AddGrade that has the signature where the parameter is of type double, a single parameter of type double. Likewise, if I do book.AddGrade and I look in this IntelliSense window, I can see the 2 overload this method. So one version of the method takes a character. The other version takes the double. What I'm going to do is pass in the character, uppercase A. And once again, the C# compiler will be able to figure out which of those two methods that we want to call even though they both have the same name. They have different signatures, and that's enough to differentiate this call. And before we leave, I'm going to delete that line of code just so it doesn't trip up our program in the future.

Defining Properties
Another type of member that you can add to a class is a property. A property can be very similar to a field in the sense that a property can encapsulate state and it can store data for an object. But properties also have a different syntax compared to fields and some more powerful features. Let me give you an example. You might remember earlier in the course when I took our field for storing the GradeBook name and I made it public. That allowed me to expose that piece of state to the outside world, and it was just a convenience so I could easily assign to that field and read that field from outside the code that is inside the book. The downside to making my field public is that anyone can set this name. They can even set it to an empty string or a null value. And if that's a scenario that I want to prevent by first validating that the name being set is not going to be null or empty, then just having this public field is not a good solution. And that's a scenario where properties can come in. So let me tell you, there's a few different approaches that you can use to declare a property in a C# class, and I'm going to start with the longhand syntax, so the syntax that requires the most typing. With this syntax, you typically start off with a field that is actually going to store the underlying state, and that field is not going to be public. It's going to be private, so you can protect this piece of state and you can control access to the state. Because I still want to give the outside world the ability to read the book name and also write and set the book name, but I went to control that access, and I could do that through a property. So before I write the property, imagine having methods like GetName and SetName, where SetName takes a string and GetName returns a string. That would be one way to encapsulate and hide this field name but still give access to the ultimate name to the outside code. That's what a property will do, but it has a sweeter syntax than method syntax. So first of all, an access modifier. I'm going to declare a public property that is available from outside of this class. Then I need to define the type of this property, so what is the type that I will let people read and write? It's going to be of type string. And then I provide the name of the property. And then I'm going to add opening and closing curly braces. So this almost looks like I'm about to write a method definition, but notice there are no parentheses after the Name symbol. Instead, what I'm going to write is the keyword get and again have opening and closing curly braces. And inside of here is the code that I went to execute when someone wants to read the Name property. So flipping over into Program.cs for a moment, with this property defined, what I'll be able to do is add a Console.WriteLine that says, For the book named, and then output the expression book.Name, so notice. I can get to that uppercase N property. And this would be reading that property. So what happens when you read a property? That would invoke getter for that particular property. So inside of here I need to return a string because that's ultimately what we said this property is. It's a string type, so I could just come up with something random. I could just return an empty string. Or I could use the field that I've created, lowercase name, and return the value that is inside of there. And that's my getter. That's what reads the property. I can also have a setter. So what happens over in Program.cs when someone says book.Name equals, and they set it to an empty string or any string, so book.Name =, and some string value? Over in Book.cs that would call my setter to write a value into this property. And again, inside of here, I can have any implementation I choose. I could choose to just ignore that write operation, but really, that's not what anyone would expect, given the API of having a public writable name property. So instead, I could say that my name field equals, and here's an implicit variable named value. So any time you're in the setter for a property, there will be an implicit variable available with the name of value. So it's almost like you've written a method and you have a parameter name value, and that will be the incoming value that someone is trying to write into your property. So I could just go ahead and assign that to name. I could also do some checks, so I could check to see if value == null, or if the value is an empty string. In fact, there's a way to do that with a string API. So there is a method on the string type, a static method, which is IsNullOrEmpty where I pass in the string that I went to test so that I could say if this value is not null or empty, only then do we set the field name to this incoming value. And I could have an else statement here that throws an exception, telling the caller that they tried to set my name to an incoming value. I'll leave that as an exercise for you, but hopefully you're starting to see the picture where there is a property that I can define, which really represents a piece of state. It represents the name about this book, and it's really a way to encapsulate that state so I can carefully control what happens when someone reads that property and what happens when someone sets that property. Let's say I only want to return an uppercase Name. Then that's possible. I could do that. That's the flexibility that a property member gives me.

Defining Property Getters and Setters
In the original release of C#, the syntax that I'm showing you here was really the only way that you could define a property. And that is you always had to have what we call the backing field that sits behind the property as a place where you can store values that are incoming. So where do I store the name, the value that is set on my property? I store that in a field that I have that backs this property. But eventually, Microsoft and the designers of C# realized that a lot of people were just writing code like this, so they wanted a property called name that was using get and set so that someday somebody might add some logic inside of here. But all this property would do is turn around and either read from or write to a private backing field. So Microsoft said, let's make this a little bit easier. What you can do is get rid of explicitly declaring that field and in fact, get rid of the default code that is inside of get and set. And in fact, you can get rid of all these curly braces if you just tell us that you want the ability to read this property and set that as write to this property. Then we'll just have the compiler generate that backing field for you and also generate the code that will just read from that field on a get and write to that field on a set. This is known as an auto property in C#, and it leads some people to wonder, well, what is the difference between having a public property like this with getters and setters and just having a public field that has the same name as that property? What is the difference between line 101 and having lines 99 through 96? Well, there are very few differences, in fact, to the client code, the code that is over here inside of Program.cs, there's no difference. I would write to book.Name, and I would read from book.Name, and I don't really care if it's a property or a field. I just know that an uppercase name exists on every book object. However, there's some places in the .NET Framework where having a property might behave a little bit differently from having a field, and most of those places revolve around reflection and serialization. So reflection and serialization, both dynamically at runtime, go in and inspect an object and see what it has available for state. And there's some places in .NET when they serialize something, they're only looking for properties or they're only looking for fields. So that would be one difference between defining a property and defining a field. But another difference, a significant difference, is that I can apply different access modifiers to get and to set. So imagine if I wanted to go back to the scenario where I want to allow anyone to set the name of a book as long as they pass the name into the constructor. I'm going to make the name required. And once you have set the name of a book in the constructor, I do not want to allow you to change the name after that point. So what I could do with a property that I cannot do with a field is say, yes, the getter, that is the ability to read this name, is always public, but I'm going to add the private keyword here in front of set, and that tells the C# compiler that any operation that wants to write to this property from outside of book.cs that code will not have access to write to this property. So coming over into Program.cs, I will see a compiler error here, the property 'Book.Name' cannot be used in this context because the set accessor is inaccessible. So that means after I've constructed the book, I will not be able to change the name. So now that piece of state is a little more encapsulated. It's a little more hidden. It's not just something I can walk up to and overwrite, and that is another advantage of using a property over a field.

Defining readonly Members
Now that we have learned how to write a read‑only property, which is what we've done with name, we've marked the setter as private, which means no code outside of this class will have the ability to write to name, so it's effectively read‑only, you might be wondering what else we can do in C# to make a variable or field read‑only or constant because many programming languages have this concept of declaring something as constant. It cannot change. In C#, there's a couple different ways to do those. First, I want to introduce you to the readonly keyword. So let's say I want to define a field, and this field could be public or private. But I want to define a field, and I'm going to mark it as readonly. It's going to be a readonly string, and let's give it the name category. And what the readonly keyword gives me is a field that I can only initialize or change or write to in the constructor. So I can only use an initializer here to set a category. Let's say the category is science, so that's a legal piece of code, and also in any of the constructors for my class. And by the way, yes, constructors, just like AddGrade, constructors can be overloaded. So I can have multiple constructors defined as long as the method signature for each of those constructors is unique, so different types or different number of parameters. But inside any of the constructors, I can also walk up to category and give it a value. So I could give it an empty string. That's legal. But if I try to take this piece of code and place it into AddGrade, this is where the C# compiler will jump in and say sorry, but a readonly field cannot be assigned to, except in a constructor or a variable initializer. And readonly is actually one of my favorite keywords. I enjoy writing classes that have a number of readonly fields because that allows me to write a class where I assign values to those fields inside of a constructor. I can assign those values, and then I can be sure no matter what else happens in this object, those fields are never going to change. So there's no other properties or methods that can ever write into those fields. I know what their values are at the start of the object, when the object comes to life and the constructor has finished executing. I know what those values are, and I know those values won't change for the rest of the object's lifetime.

Defining const Members
Another keyword that you will find in the C# language is the const keyword. Const has even stronger semantics than readonly. That means the rules are a little more strict. So I'm going to change this category field from being readonly to being a const field. And now, if I scroll up to the top of Book.cs, this first line of code inside of the constructor, which previously was legal, because I can still write to a readonly field inside of the constructor, this now generates a compiler error, and I am told that the left‑hand side of an assignment must be a variable, property, or indexer. In other words, my const field is no longer a variable. It's no longer something I can write to from anywhere. So even here in the constructor, I cannot change that constant value. And I also want you to know that you can declare local variables as const. So if I want a constant integer value, let's name it X, and I'll give it the value 3, I can now use this symbol X throughout the rest of the method. I just can never write to it or do anything that would try to change the value. So even using the increment operator, which tries to add 1 to the value inside, that's going to generate a compiler error, because the C# compiler will catch that. Now if you declare a constant field and have it as a private field, so this is only available inside of the book class, that's perfectly acceptable, but let's say you have this const field and the string value is something that has some value outside of the book class. Someone else wants to know what the string value is. In that case, it's perfectly acceptable to mark this field as public. There's no need to wrap this field with a property, because the only thing that anyone can ever do with the string field is read the field value, and then because this field is publicly exposed, what a lot of developers will do, and this is something that crosses different programming languages, is they will always put their constant values as all uppercase. So this would be category all uppercase, which again isn't required. Some developers use this convention just so you can visually identify what is a constant and what is a variable. And now something special about const values. If I want to reference this category field from outside of Book.cs, then I need to know that const fields are treated like they are static members of the class. So we learned about static earlier in the course. A static member, you cannot access a static member via an object reference. You access a static member by using the type name. So inside of Program.cs, let's say I want to Console.WriteLine the category. In order to do that, I will need to use the class name, which is Book, and now I can reach category. I would not want to go through lowercase book, the variable that holds an object reference category is not available there. And if you think about it, that's really makes sense, because category is a constant; it's never going to change, and it has to be initialized to a constant value that the compiler knows about. There's no need to have this as a piece of state inside of each object, because it's going to be the same value, no matter which object I go to. So it's much more efficient to just associate this field like a static field and make it associated with the type instead.

Introducing Events and Delegates
For our next topic. We're going to look at another member that you can add to the class, a member known as an event, I'll tell you that I have been debating whether or not I wanted to cover events in this course for two reasons. First, even though events have been around since the beginning of the C# language, they're not used as often in today's frameworks compared to the frameworks that also came out around the beginning of when C# started. For example, if you look at the new ASP.NET Core Framework, which is for server‑side and web programming, there's very little use of events, and combine this with the second reason why I almost didn't cover event in this course, which is, they are the most difficult topic to understand. But I do want to take some time to cover events and explain what they are and how they behave, because there's a good chance you will still run across an event somewhere in your C# programming, especially if you are programming with a framework like Windows Presentation Foundation, WPF, or Xamarin.Forms, or Windows Forms, or ASP.NET Web Forms. All those frameworks use events extensively. Before we can understand events, however, we have to understand how to build a new type with the C# language, a type known as a delegate.

Defining a Delegate
To understand what a delegate is, let's open up our TypeTests file because the first thing to know about a delegate is that it does describe and build a new type for .NET. But a delegate is very different from a class definition or a struct definition. With a class, I define a type that has methods, and properties, and fields, but with a delegate, what I'm really going to do is describe what a method will look like because here's what a delegate really is. When I define a variable that is typed as integer, I'm going to use that variable because it can hold different integer values. Same thing for a floating point variable. Same thing for a variable that is typed as book. I want that variable to be able to point or refer to different book objects that are in memory. What a delegate allows me to do is to find a variable that can point to and invoke different methods. But it's not just any method that a delegate can point to. It's a method that has to have a specific shape and structure. So when I define a delegate, I'm really defining what a method has to look like. In other words, what is the return type of the method that you expect to call? What are the parameter types and numbers of parameters that you expect to pass when you invoke this method? That's what I'm defining with a delegate. So, for example, imagine I want to define a delegate that allows me to log messages. And the important part to remember here is that I'm going to define a delegate because I need some sort of indirection or abstraction or encapsulation between my code and the code that ultimately does the logging. So when I invoke a method and say, please log this message, I don't want to be hard coded to a method that only writes to the console or hard coded to a method that only writes to a file. I want the ability to have a variable or a field that can point to different methods that have the same structure, but perhaps vastly different implementations. So one can log to the console, one can log to a file. So if I were to dream up a delegate like that, it would look like this. I would first start off with a public keyword, so I'm creating a public type that can be used outside of this project. Then I use the delegate keyword. So so far we're not much different from defining a class. So instead of public class, I have public delegate, but here's where things start to take a strange turn for a lot of people because now what I'm going to describe is what a method would look like. And that means the code I'm going to write is going to look almost like this. I'm going to have something that has a return type and a name and then parentheses with parameters inside of it. So, if we think about a logging method, well, that logging method probably returned void. But just to make testing a little bit easier, I'm going to say that this particular delegate needs to point to a method that returned a string. So that's my return type, just like every method has a return type defined. And then I provide the name of the method, only in this case, it's going to be the name of the delegate, and what I need to do is come up with some sensible name like WriteLogDelegate. So yes, this, again, it's looking like a method definition, which a lot of people find very confusing. But as you're about to see, what I'm really doing is defining a new type, a type that I can use to define variables and fields. So the next thing I need to do is describe the parameters that a WriteLogDelegate would take. And I want every WriteLogDelegate to take a parameter named logMessage or, more accurately, to take one parameter. That one parameter is of type string. The name of the parameter really doesn't matter, so this could be called foo or bar. The important part is I'm building a delegate, a delegate that describes any method that returns a string and takes a string. Now let's write a test that uses that delegate. So I'm going to write a fact that my WriteLogDelegate can point to another method in this class. I want to have a method that matches what a WriteLogDelegate can look like. Another method that we implement right here, and I want to be able to invoke that method through a variable and prove that this is working, but first of all, how do I write a method that will match this delegate type? Well, I have to have a method that returns a string, and by the way, this method could be public or it could be private. In fact, let's just leave it as a private method, and this isn't going to be a method that is a fact. It's not a unit test. It's just a method that I want to invoke for my test. And now I can give this method any name that I want. I could just call this method ReturnMessage because all it's going to do is take a parameter named message, and then it is going to return that message to the caller. So again, the important part here is not the method name. The method name doesn't have to match anything with this delegate. The parameter names don't have to match anything that you see here in the delegate declaration. The important part is the return type. Yes, that matches. It's a string return type, and there's one parameter that comes in and it is of type string. That is what my method has, and that means I can now declare a variable. Let's explicitly declare a variable of type WriteLogDelegate. I'll name the variable log, and, ultimately, what I want to do is invoke this variable because when you have a variable or a field that is a delegate type, well, you are referring to a method. And what can you do with a method? You can invoke a method by applying parentheses. So I want to invoke the method. Notice, I have a compiler error that says, sorry, but you have to give me an argument to pass along as the log message. It has to be a string. So, yes, we will provide that argument, which is Hello! I'll also notice that the result here will be typed a string because the C# compiler knows when I invoke log, it returned a string type. And, yes, right now log is unassigned, but we'll fix that in a moment. All I want to do is assert that I have expected the value Hello! to come out, and that expected value should match the result. And now all I need to do is to point log at that method. There's a couple different ways to do this. One way to do this is using a longhand notation, which I'm going to show you just because it might make things a little bit easier to understand. So a delegate, just like a class, is something that I can instantiate with a new keyword. So I could say log =, and I'm going to say that I want a new WriteLogDelegate, and then in parentheses, I pass in ReturnMessage. So again, part of what makes delegates confusing is that I am not passing in ReturnMessage. I'm not invoking that method and trying to pass in a return value. I'm simply providing the symbol to say yes, I want a new WriteLogDelegate, and I went it initialized to reference this ReturnMessage method that is somewhere else on my class. But another way to write this expression is to just say that log = ReturnMessage. And behind the scenes, what the C# compiler will do is say, ah yes, we will create a WriteLogDelegate, and we'll initialize it to point to this ReturnMessage, and then you can invoke log as many times as you want, and that will actually be invoking this method down here. And if we save all of our files and come out to the command line, I should be able to run dotnet test, and it turns out we have an error, Property or indexer 'Book.Name' cannot be assigned to due to some of the changes that we made previously. And that problem should be occurring here in this file where we are trying to set the book.Name. Yeah, so that's down here. And actually, in order to fix this so that I don't have to rewrite my tests, let's say we're going to allow people to set the book.Name. So let's come into Book.cs. Let's find our definition for the Name property, and instead of making this a private setter, we'll allow that setter to be public. So save all the files back to the command line. Once again, run dotnet test. And hopefully, yes, we have a successful test run. So that is just demonstrating that I can declare a variable that is a delegate type. And now what I can do is I can point this variable to any method that returns a string and takes a string. That would be a WriteLogDelegate. That's how we described a WriteLogDelegate. And after I've initialized that variable and it is pointing to a method, I can then invoke that method using parentheses. But here, on this line of code, I don't know exactly what method I'm invoking. I only know because I can see the line of code where a specific method gets assigned. But imagine someone passes me this variable as a parameter. I'm off in some other piece of software writing code. All I know is I can invoke that delegate. It's going to do something that takes a string and return a string.

Using Multi-cast Delegates
What's very interesting about delegates in .NET and also admittedly adds some confusion is the fact that delegates can invoke multiple methods. They are what we call multi‑cast delegates. In other words, this line of code is assigning ReturnMessage to my WriteLogDelegate variable, which is essentially saying when you invoke log, I want you to invoke this method, ReturnMessage. But I can also use a += operator here. Now we've seen the += operator previously in the course. We've used it with integers, and we've used it with doubles, and it always means that I want to combine the value that's in the variable with this new value and then place the combined result back into the variable. And that's exactly what's happening here. I want to take whatever is in log, that variable, combine it with another method call to return message and put that combination back into my delegate variable log. So when I invoke log, there is the possibility of invoking not just a single method, but multiple methods. Now, currently, I'm going to have an error because I'm using an unassigned local variable log. So what I'm going to do is add an assignment to this variable. I'm going to start off with an assignment to ReturnMessage, and then the next line of code here is saying and also I want to invoke this other method, ReturnMessage. It just so happens they're both the same method, but I can actually do different methods with this delicate invocation. How do we test this? Well, instead of asserting that we're receiving a result back from this delegate because now we're really going to be invoking different methods, and in the end, I don't want to depend on a specific result. Instead, I just want to count how many times I'm invoking a method. So let me declare a field in this class, a private field named count. We will initialize it to 0. And now before every test runs, the testing framework will construct a new instance of this class, which gives me a new object and runs this field initializer so I know count will always start off as 0. And inside of this method, ReturnMessage, I just want to increment count. And to prove a point about delegates, I want to make a copy of this method and paste it here. And let's give this method a different name. We will have to because the method signature exactly matches an existing member that we have. So let's call this IncrementCount. But we'll have the same code inside. I mean, we could have slightly different code. I could return message.ToLower instead of just message. But the important fact here is that the delegate type still matches. So I'm still returning a string, and I'm taking in this method a single parameter of type string. And what that will allow me to do is say, log, I also want you to invoke IncrementCount. So now when I invoke the log method, we should be calling ReturnMessage twice and IncrementCount once. And although I might know the implementation details about delegates well enough to assert what the results should look like because I can figure out if the delegate will be invoking IncrementCount last, so the string will be ToLower, but it's a little bit safer to assert just on the count here. I want to assert that I expect the count to be 3 and the actual value is in my field count. And with those changes in place, let me save the file. Come out. And let's run a quick dotnet test to make sure this does work. And, yes, the test run was successful. So when I invoked log, I invoked ReturnMessage twice, and I invoked IncrementCount once. And, again, this can be a point of confusion with delegates, but it's also a very flexible and powerful feature of delegates, the way I can define a variable and point it to different methods, even multiple methods. And those methods don't have to have the same name. They don't have to have the same logic or implementation inside. The only thing these methods must do is they must satisfy my delegate type, and my delegate type says you need to return a string and take a single string parameter. If I don't do that, then I will receive compiler errors that the method I'm trying to point my delegate to does not match that delegate type. So this return type, if I want to use this method like I'm using it, has to be of type string. But other than that, the method names don't matter. The names of the parameters don't matter. And even though my delegate is called a WriteLogDelegate because I expect to be pointing at two methods that will write information to some sort of log, like to the console or to a file, that really doesn't dictate anything about the actual implementation details. So I could do something simple, like increment a counter or Console.WriteLine or do anything I want that's not related to logging at all. All that really matters with delegates is the return type and the number and the types of parameters. And what delegates give me is the ability to declare a variable that I can use like a method. So it's a variable that I can invoke and pass along parameters.

Defining an Event
Now that we know a little bit about delegates, we can talk about events. So imagine this scenario. Imagine there are components or pieces of code or other areas of our application that need to know when a grade is added to the grade book. And you might say, well, that's easy. Whenever we call book.AddGrade, that's when we're adding a grade to the grade book. So if I need something to do some additional work whenever we're adding a grade, then why don't I just place that line of code right here? But it's not nearly that simple. This other piece of code, this other component, this other piece of software, it might be in a different file and be responsible for completely different activities. It might be code that we do not want inside of Program.cs. And this code could be doing anything. It could be logging or recording the fact that we're adding a grade. It might be keeping track of how many grades per minute a particular user is entering so they can figure out the usage of the system. There's many reasons why I might want to know when a grade is added to the grade book, just like when someone walks up to a form that's inside of a window and clicks on a button. There's going to be pieces of code inside that application that need to know when the button is clicked. So that is an event, and what we're trying to simulate here is an event. So you can think of a button click as a significant event that we have to tell the world about. And although this grade book has a very simple console command line user interface, we can still think of adding a grade to the book as a significant event. And really, it's only the grade book itself that can tell us when a grade has been added to the grade book because it wouldn't be until we reach line 42 here that we know a grade has been added into the collection of grades that this book is managing. So somewhere here right at this point, we want to call into another piece of software to do some work, to tell that other piece of software, that other method, that we've added a grade. But it's not the book's responsibility to keep track of everyone who wants to know when we add a grade. That's just not possible. In fact, when I write this book, when I'm working with my C# code and compiling this code, who might want to know about when we've added a grade to the grade book? And this is where delegates become useful because if I can define a delegate and have a field that is a delegate, at runtime, someone can point that delegate to different methods and different pieces of code that are available somewhere else in the application, I have no idea where, from inside of Book.cs. All I know is that if I invoke that delegate at the appropriate time right here, then I can announce to the outside world that, yes, we have just added a grade to the grade book. So let's think about what that delegate would look like. I'm going to declare a new type here inside of Book.cs. Many people would place the delegate definition in a separate .cs file because a delegate is a type, and I mentioned the convention earlier that we typically use one file per type with C# programming. But in this case, I'm going to save us a little bit of time. So first of all, what would a delegate return? Well from the book's perspective, I'm not concerned at all about what the delegate might return. I'm not expecting a value back when I announce to the world that I'm adding a grade. I just want to make that announcement. And remember at this step, all I'm trying to do is describe the type of method that I want this delegate to invoke, so the return type is void. Then I provide a name for my delegate. Well a good name for this might be GradeAddedDelegate. That's the name of my delegate. And, of course, I also need the delegate keyword. So I'm building a delegate that returns void. Its name is GradeAddedDelegate. And then what are the types of parameters that I want to pass along? Technically, it is perfectly legal to define a delegate that takes no parameters. It's also perfectly legal to define a delegate where I can pass along the grade that I'm adding to the grade book. But I will tell you there is, again, another convention in .NET that most developers follow when they're going to build a delegate to define an event as part of some class. So what we're really looking to do with this delegate is to define an event, which I'll explain in just a bit. But all events in .NET typically have two parameters, the underlying delegate. The first parameter is of type object. We haven't really seen or talked about this type in this course yet. And so some of the mysteries of this object type might not become apparent until we get to the next module when we talk about object‑oriented programming with C#. But for right now, I just want to tell you that object is the base type for everything in .NET. Anything that we work with, whether it's a book or an integer or a floating point number, they all have some relationship to this object type. And when I declare a variable of type object or a field or a parameter of type object, I can pass anything through that parameter. So it doesn't have to be a string or a character or a double or a floating point number or an integer. It can be all of the above. It can be a book object. Anything will fit into that object parameter. And typically, the convention is in .NET, that is always the first parameter that you pass as part of an event delegate. That first parameter is the sending. Who is sending this event to the rest of the world? And then the second parameter is some form of event arguments. We'll call these args. And at this point and in this module, there's really no additional information that we can pass along with our event args. But once you go a little bit further with C# and you learn about inheritance, which we're going to do in the next module, and perhaps you learn something about generics, which is covered in a different course that I have, then you'll be able to pass along whatever information you want with this EventArgs. For right now, I just want to focus on using this delegate and creating an event on my book, an event that will publish to the world when we're adding a grade. And then in the next clip, we can listen for that event and do something interesting whenever a grade is added to the grade book. But first I need an event. So an event, much like a field or a method or a property, can be a member of a class. So down here, let me create a public member of the Book class. I'm going to give it the type GradeAddedDelegate, and I'm going to give it the name just GradeAdded. So from outside of Book.cs, anyone can walk up to a book object, and they knew they can do book.GradeAdded. And that will be a delegate that is invoked whenever a grade is added to the grade book. Now at this point, I just want to be clear. This is just a field on the Book class. But what I'm going to do is use a new keyword that we haven't seen before, and that keyword is the event keyword. Without getting into too many low‑level details, this event keyword adds some additional restrictions and gives some capabilities to this GradeAddedDelegate that makes the delegate safer to use. I'll explain that when we get to the next clip. But now I have a Book class definition, and every book object will have a GradeAdded event. And any code that is interested in knowing when a grade has been added to the grade book can find out because we are going to invoke this delegate inside of AddGrade. So just after we have added a grade into the list of grades, I'm going to first check if GradeAdded is equal to null because I only want to try to invoke this delegate if GradeAdded is not equal to null. If GradeAdded is null, that means essentially no one is listening. No one cared enough to add a method reference into my delegate. So I don't need to announce to anyone that a grade has been added because no one's listening. But if GradeAdded is not null, then I want to invoke GradeAdded, so apply some parentheses, only I need to pass along those two parameters that we described in the delegate type. The first parameter is the sender. That's where I can use the this keyword to say I am the sender. This object reference that you're currently working with is the sender of this event. So pass along sender with the this keyword. And then I need a new instance of the EventArgs class. So I'll create a new object from that class definition and pass that along as the second parameter. And again, EventArgs is where you can pass along additional information about this event. For example, it would be nice to pass along what is the value of the grade that we're adding to the grade book? And that's something we could do with EventArgs, but it just requires some knowledge of inheritance, and we'll talk about that in the next module. For right now, I have something that I should be able to use for the rest of my program.

Subscribing to an Event
Now that we've seen how to define a delegate and how we can use that delegate to define an event member as part of a class, let's see how we can handle that event. So when I handle an event, that's what we say when we add a method to this particular event that we want invoked when this class raises that event. So raising the event is really just invoking the delegate, and handling the event is really just using that += operator to add a method into the invocation list. So over in Program.cs, I can handle that event from anywhere where I have a book object. So if we want to handle all the AddGrade events, I would typically add a step here right after I initialize and construct the book. Then I want to tell the book that I want to handle the gradeAdded event. And, of course, to handle this event, I'm going to need a method that can be invoked when the book raises that event. And what is that method going to look like? Well, again, it has to look just like this delegate declaration. This delegate says you can invoke any method that returns void and takes the first parameter of type object and takes the second parameter of type EventArgs. So inside of Program.cs, let's add another method to this class that we can invoke. Now, we're about to use that method inside of a static method, the static main method, and remember how I told you that once you have a static method, you might start adding more static members to a class because the only other members a static member can reach are the other members that are static. So if I need a method that I can touch from inside of the main method, it has to be a static method. And then the delegate says it has to return void. It has to have a name, which we'll talk about in just a second. For right now, I will just call it A. But it has to take one parameter, the first parameter of type object ,and the second parameter of type EventArgs. So this is going to be a method, and now I can give this a name, perhaps OnGradeAdded. So this is what we want called when a grade has been added to the gradebook. And again, this code can be completely decoupled from the book itself, so the book has no idea about this method inside of the main method of Program.cs. But up here at the top after I initialize the book, I can say book.gradeAdded, and then I can say += OnGradeAdded. And again, since this event is a delegate, which is really a multicast delegate, I could += as many methods as I want. And in fact, something I haven't told you about yet, is I can also use ‑=. So I could say book.GradeAdded, I want to subtract out a call to OnGradeAdded. So now what should happen, every time the book raises the event gradeAdded, that event should invoke this method OnGradeAdded twice because we've added that method three times, but we've subtracted it once. So again, another piece of the puzzle for delegates and events that might seem strange and mysterious, and that's understandable. When I first started learning how to program with C#, delegates were by far the hardest topic to learn. Now, if you come from a background where you've used Lisp or some other functional programming language, perhaps even JavaScript, then this idea of assigning methods to variables and passing methods around might not seem so strange. But for many of us, it takes a while for all this to sink in, and that's normal. For right now, to just to see this operate, let's come down into that method and let's just do a simple Console.WriteLine, and just display the message A grade, was added. Now, if I save all my files and come out to run this application, we'll do that by passing in the project flag. Go into src\GradeBook, and the name of the project is GradeBook.csproj. Every time I enter a legal, valid grade like 91, I do indeed see that message twice, A grade was added. If I enter an illegal grade, a 103, I'm told that's an invalid grade, and also notice that the book object doesn't raise that event, so I don't display any messages about a grade being added. And the syntax we're seeing here is the same syntax that I showed you inside of the unit test where we first started working with delegates. But there is one significant difference between the code that you can write here against an event, versus the code that we wrote in the unit test against a pure delegate, and that is this. If the book class exposed this GradeAdded member as a delegate, I would be able to make a direct assignment into that field, so I could say something like GradeAdded = null. And typically that's not something that you want to allow from the outside. You don't want just anyone to be able to walk up to this field and directly assign it any value. By assigning null, I would be wiping out anyone who had previously handled or subscribed to listen to that event. But the reason I'm receiving a compiler error here is that once I mark that field as an event, now the C# compiler adds some restrictions to that field, and some types of code like this become illegal. So notice book.GradeAdded can only appear on the left‑hand side of a += or ‑= operation, so trying to directly assign to GradeAdded is not allowed. I can only use +=, which is more of a combine operation, and ‑+, which is a subtraction operation. So delegates and events might take awhile to sink in. And honestly, if you're working with something like the ASP.NET Core framework, which is used to build server‑side applications on top of .NET Core, then there's a chance that you might never see events, at least not on a day‑to‑day basis. But if you're using one of the frameworks that is used for desktop programming or mobile programming, something like Xamarin Forms or WPF, then there are lots of events in those frameworks, because every UI interaction becomes an event. When was this button clicked? That's an event. When does the mouse move? That's an event that I can listen for. And so in those environments you'll need to become comfortable at least with this idea of being able to subscribe to an event and listen to that event and writing an event handler or code that will react to a particular event.

Summary
In this module, we expanded our knowledge of the members that we can add to a type. So now we know we can add methods and fields, but also properties and events. To understand events, we had to look at delegates, possibly the trickiest subject when you're learning C#. But we'll be able to build on all this knowledge when we move into the next module and look at object‑oriented programming with C#.

Object-oriented Programming with C#
Introduction
Hi, this is Scott, and in this module, we are going to look at object‑oriented programming, or OOP, in C#. This means we will learn about topics like inheritance, polymorphism, and encapsulation, and how we can achieve these OOP techniques using the C# language. This module is fast paced and contains a number of challenges for you, so warm up your fingers and your editor.

The Pillars of OOP
In software, there are what we call the three pillars of object‑oriented programming. These are the concepts that object‑oriented programming languages support with different language features. One pillar is encapsulation, which we've already talked about. Encapsulation allows us to hide details about our code, and we've seen how methods and properties allow us to encapsulate code. Also, access modifiers like public and private, give us explicit control over encapsulation and who sees the members of a class. What's new in this module is inheritance. We will look at how inheritance gives us the ability to re‑use code across similar classes, and we will also look at polymorphism, which allows us to have objects of the same type that can behave differently. I'll show you an example using one book object that keeps grades in memory and a second book object that stores grades in a file. I do want to mention that of these three pillars, encapsulation is, to me, the most important pillar. Encapsulation is a technique you need to apply every day and with every bit of code that you write. Polymorphism is useful, too, and it's something you'll probably see in day‑to‑day programming with C#, but inheritance is, in my opinion, often overrated. Yes, you'll probably work with classes that inherit from other classes every day, but in solving your own day‑to‑day problems, encapsulation is the key to good software design, and it's what you should always focus on. Let's dig into Inheritance and polymorphism.

Deriving from a Base Class
Inheritance is a feature of object‑oriented programming languages, and what inheritance allows you to do is define a base class. Now we all know that a class contains members and members represent the state and behavior of a particular class. And any members that I write in a base class, I can inherit into what we call a derived class and allow those base class members to effectively be members of my derived class. So quite often we use inheritance so that we can reuse code because if I place code inside of a method in a base class, any class that I derive from that base class will contain that base class method. So let's make this concrete by going back to our book example. So let's imagine that inside of this Gradebook application, I have a number of different classes that require a name. So currently we have a Book class, and a book requires a name, so we have a constructor that takes a name, and we have a property that holds that name. But let's say we want to have other named objects in this project. There's lots of things that can have names in software. We might have students that need a name and schools that need a name and employees that need a name. And I could certainly go and write classes for all those different entities that are in my software, and inside of each of those classes, I could have a field or a property with the name of Name. And remember, this is a very simple property, but it might be that I have validation logic here to make sure that the name is not going to be empty and the name is not going to be null, and I don't want to have that code duplicated everywhere through my software. I want to follow the DRY principle, which maybe you've heard of; DRY is Don't Repeat Yourself. That's particularly important with significant pieces of logic. But let's create a new class. Let's call it NamedObject, and inside of this class definition, I'm going to create a property with the name of Name and getters and setters that are public so this will allow the outside world to set that name. I now want to use this class definition as a base class for all these other types that I want to build, the Student class, the Employee class, and so forth, and also the Book class. The book already has a name. That's how we refer to fields and properties inside of a class, we say a book has a name, but now I want to establish an inheritance relationship between Book and NamedObject so that I don't need to write a Name property inside of book, instead I want to inherit this property from the base class, which is NamedObject. So, scrolling back up here to the top, the syntax to do this is to use a colon and then to specify the name of the base class that I want to use. So, the name of the base class is NamedObject. And when we talk about the inheritance relationship, we say Book is a NamedObject. So a book has a name, but a book is a NamedObject, and because the book is a NamedObject, a NamedObject provides a name, this property gets inherited into a book, and therefore I can walk up to a book and I can interact with the name because it's part of the base class, it's effectively a part of the book class. From outside here, I don't really exactly know if this is part of the base class NamedObject or if it's a part of the Book class definition, and I'm not particularly concerned about how that was put together. All I know is that a book has a name. And while we're in here, let's go ahead and remove these other event handlers, which were just there to demonstrate that you can subscribe multiple times and also unsubscribe from an event. So now my book has a name, and my program will still compile, and my test will still pass, and all the code that I have that is using a book should behave the same as it was before. And even though I recommend that you always place a class into its own dedicated file, I am going to leave this NamedObject class here inside of book.cs, we'll have multiple classes here. That's just to make things easy for this module, so we don't have to jump around through different files. But in your own project, feel free to put NamedObject in a different file. And now I can go out and create other classes that derive from NamedObject, so I can create the Student class and the Employee class, and I could have them all derive from NamedObject, and I would never have to write another public string name get and set again. However, there is one significant difference between a Book and a NamedObject, and that is that a book requires a name to be instantiated. So, yes, inside of program.cs I can instantiate a NamedObject and I can declare a variable of type NamedObject, and I could say var n equals new NamedObject, but when I construct an instance of NamedObject, I am not required to pass along a name. There's no constructor that enforces that rule. A book, on the other hand, has a constructor that forces me to pass along a name so that we initialize a book right from the start with a name. Let's see how to do that with NamedObject next.

Chaining Constructors
Let's temporarily say that book is not derived from NamedObject, so I'm going to remove that little bit of code. And I'm going to make some changes to NamedObject. I'm going to add a constructor. One easy way to do that is to place your cursor on the class name and press Ctrl+period. This works in Visual Studio and Visual Studio Code, but I can say generate a constructor for me, please. So now I have a constructor for NamedObject, and I'm going to create a non‑default constructor, a constructor that requires a name parameter and then effectively just say yes, the name property equals that's incoming name value. And now every NamedObject will be required to provide a name at initialization. So currently down here in book, I have an error that name does not exist. That's because book effectively doesn't have that property anymore. But now I'm going to derive from NamedObject, and now we will have a different error. The error now is that there is no argument given that corresponds to the required formal parameter name of NamedObject. That is a long‑winded way of saying your base class requires a name. It has to be constructed in a specific manner, and you have not given me enough code to tell me how to construct your base class. So when we construct a book, we're also effectively constructing a NamedObject. These are going to be two different objects. With the inheritance relationship, a book is a NamedObject, so a book contains everything that a NamedObject has. But since the NamedObject constructor requires a name parameter, I have to tell the C# compiler how we're going to construct the NamedObject when we're constructing our book. And the way I do that is to use a colon. And now here's a new keyword in the C# language, the keyword base. So we've seen the keyword this, which refers to the object that I'm interacting with. I can use it inside of instance methods, like a constructor, and say this.name if I want to be explicit. Yes, I want to reference the property that the this reference is pointing to, and this keyword base is a way that I can reference my base class. When I say base and then use parentheses, you can think of this is accessing a constructor on my base class, so it's accessing this method. And just like when I used the new keyword, I can pass along arguments that are required. So if that base class constructor requires a name, I need to pass a string along. In this case, I'd be passing along an empty string, so my book would have no name. But since someone has given me a name to my constructor in book, I can pass that name along to any NamedObject. And again, this is a pattern that I could follow for the other derived classes that I build. So when I build a Student class and a student is a NamedObject, then with the student constructor, I can take any name parameter that comes in and just pass it along using the base keyword to NamedObject. And now over in Program.cs, I can still see that yes, we're constructing a book and I'm passing along a name parameter. And in fact, I can access properties like name even though it wasn't defined syntactically inside of the Book class. It was inherited by the Book class from that base class. And that inheritance relationship also explains some of the other methods that I see on my book object. So where does ToString come from? Where does GetType come from? Where does GetHashCode come from? Those are all methods that I can invoke on a book object, but those are not methods that I defined. So let's talk about what is happening in that situation.

Deriving from System.Object
In .NET every class has a base class. It doesn't matter if you specify explicitly the base class or not, every class is going to have a base class. So here in our code, we now have a Book class with a base class of NamedObject and we can see that NamedObject does not explicitly specify a base class. I could, I could write another class, let's just call it the Thing class, and I could say NamedObject derives from Thing, and there really is no practical limit to how far the inheritance hierarchy can go. So,Book derives from A, A derives from B, B derives from C. C derives from D, and so on. That can just keep going. In practice, inheritance can make code difficult to follow, so we usually don't have extremely deep inheritance hierarchies. However, the real point I'm trying to make is that even if I didn't explicitly specify, a base class for NamedObject, NamedObject would still have a base class. That's because in .NET everything will derive from Object. So if I do not explicitly specify a base class for NamedObject, Object will derive from a base class that's from the system namespace, so System.Object. And what does Object look like? I'm going to place the cursor on this Object keyword and used this trick where we press F12 to go to the metadata view, and I can see, yes, Object is defined as a class. It has a constructor, and it also has, if I scroll down, some static methods, like Equals and ReferenceEquals, and remember a static method, I can always reach it through the type name. So if I go back into the editor and type Object dot, I'd be able to invoke this method and say Object.ReferenceEquals. But those other methods that we saw in the IntelliSense window, methods like GetHashCode and Equals and GetType, those are all defined on the base Object type, including the ToString method. So anything that I walk up to in .NET, whether it's an int or double or a Book class that derives from NamedObject that derives from Object, or some class that follows an inheritance chain that is 12 classes deep, everything in .NET is going to have a ToString method because everything inherits ultimately from this base System.Object class. And if you remember our discussion about reference types and value type, then yes, that's another way of saying that everything in .NET, by default, is a reference type because everything is defined by a class, System.Object was a class. There's also a friendly keyword for System.Object in the C# language, and that's object with a lowercase o. So just like the keyword double maps to system.double and int maps to system.int32, we have object with a lowercase o that maps to system.object with an uppercase O. Now very few developers will explicitly list the base class, as the base class is just going to be a system.object, so I'm going to remove that bit of syntax. But this should now explain some of those other methods that you see pop up in IntelliSense everywhere. Methods like ToString, they're all inherited from the ultimate base class, which is Object.

Setting up a Scenario
We're going to continue to use inheritance in different ways inside of this module. But I do want to get to a point where I can demonstrate polymorphism using a scenario that is somewhat realistic. And here's how I want to do that. Over in program.cs, currently we have quite a bit of code inside of the Main method. You might remember at one time I said that we wanted to get code out of the Main method and put it in other places, like inside of the Book class. And now we're back to having more code than will fit on a screen. So what I'm going to do is take everything from line 13, which is the start of our while loop, and I'm going to highlight all of the code down here until we reach the point where we are out of the loop and we compute our statistics. And with all of that code selected, I'm going to click on the little light bulb that appears and I'm going to select Extract Method. Note that you can also do this Extract Method technique inside of Visual Studio. Hopefully you remember when we talked about refactoring earlier in the course, we talked about that when we were in the unit testing module. Well Extract Method is one refactoring technique that you use to rearrange code. So I'm going to use Extract Method. And what that does is take all the code that I've highlighted, analyze the return type, analyze what parameters are needed, and it will place all that code inside of a new method. So now, instead of having all about detail right here inside of my Main method, I have encapsulated all the operations here inside of this NewMethod. Now we just need to be concerned about the name. NewMethod is not a very descriptive name. So what's going on here? This is where we are entering grades. So let's rename this method as EnterGrades. And I'm going to copy that identifier and paste it up here, so we invoke the correct method. And now, ultimately, here is what I went to demonstrate. This method is receiving a parameter of type Book, and because of that we can make some guarantees about this object. We can guarantee, for example, that I can walk up to this Book object and find a name property and a grade added event, and an AddGrade method. What I cannot guarantee is I cannot guarantee what exactly happens in the different implementations for the property and the event and the method AddGrade. And what I went to demonstrate to you is how we can reach a point where I can pass in a Book and I can add a grade to that Book and adding that grade will store the grade in a list, an in‑memory list that the book maintains. And then I could make a simple change in how I construct a Book object. And then when I'm inside of the method, EnterGrades, anytime I add a grade to the book, that grade will be stored on a file that lives on my hard drive. And that's going to be that essence of polymorphism. Polymorphism is in a way a form of encapsulation because it is another technique that hides the underlying details and the implementations of what's really happening behind this object I'm working with. So I receive a book and from my perspective, inside of this EnterGrades method, I don't particularly care if you're storing information into a file or over the network or keeping it in memory. All I know is that I have a Book object and I can do things like invoke the AddGrade method. But what's useful is, though, even though the implementation of how a grade is actually stored is encapsulated and out of my view, those implementation details can even change without my knowledge. So polymorph, that word, means an object or material which takes various forms, and polymorphic behavior would be behavior that can change. How that happens and the exact details are encapsulated from me, but polymorphism is useful because I can write methods and I can write code that is very generic and doesn't have a dependency on a specific implementation. I can work with books that store information to the hard drive. I can work with books that store information over the network. I can work with all of that from inside of this method. Just give me that Book object. This is what we're going to take a look at in the following clips.

Defining an Abstract Class
To achieve the polymorphism that we want from this book type, I'm first going to introduce you to a new type of class known as the abstract class in C#. An abstract class looks just like a regular class definition, except I will use the abstract keyword when I define the class. After that, everything else is mostly the same. So, for example, I provide the class a name, and I'm going to call this BookBase, but only temporarily, because I do not like the word base in a class name. Although the intention here is to be a base class for other types of book, I don't need to see the word base in the class name. So we will have a regular class definition here. But my goal is to have some polymorphism so that classes that derive from BookBase can have different implementations of AddGrade. In other words, anything that is of type BookBase should have an AddGrade method that takes a double. But one class that derives from BookBase might save that grade in memory, while another class that derives from BookBase might save that grade in a file. So to express that, I'm going to define a method inside of BookBase, a method that returns nothing so it returns void. It is named AddGrade, and it takes one parameter of type double, and we will name that grade. But what do I provide here for an implementation? That's what I don't know at this level, inside of this base class. All I know is that any type that is a BookBase, remember, inheritance is all about the is a relationship, so any type that is a BookBase should have an AddGrade member. It should have an AddGrade member that is a method that takes a single parameter of type double. That's all I can really guarantee at this level. And because of that, I'm going to create what's known as an abstract method. So inside of an abstract class, you can have an abstract method, and an abstract method is a way of telling the C# compiler, once I spell abstract correctly, that I want anything that is a BookBase to have an AddGrade member, but at this level, I cannot provide an implementation. I don't know what that implementation should be. Let the derived types that inherit from this base class figure out the implementation. And that would be exactly what I want to do with the book class. Now in C# there is single inheritance only. So I cannot say that a book is a named object, and a book is a BookBase. That's legal in some languages, but not C#. But what I can do is I can say, a book is a BookBase and a BookBase is a NamedObject, and by doing that I have now given every BookBase a property called Name. And since a book is a BookBase, my book will still have a property called name. But once again, I'm going to need to do a quick fix up because the C# compiler will tell me, sorry, but BookBase is not constructing its base NamedObject correctly, so if I place the cursor here and press Ctrl+period, I can generate the constructor that will take a name parameter and forward that to the Named Object constructor. That's perfect. That's just what we had to do with the Book class earlier. And now, everything about BookBase looks correct. I have a proper abstract class definition, but now my Book class has an error. This error is that book does not implement an inherited abstract member AddGrade. So any time you inherit a member that is abstract, like this class is inheriting a member, AddGrade that is abstract. If you're creating a type that you want people to be able to create and instantiate with the new key word, you're going to have to provide an implementation for that abstract member. So there's lots of subtleties and nuances about abstract classes in C# that I won't have time to go into in this model. But my goal is to show you some primary use cases and give you the right information and the terminology, so that if you need to figure out things on your own, you'll know what to search for and look for in the documentation. So my Book class needs to provide an implementation of AddGrade. While a book already has a method named AddGrade, it has the right return type, and it takes the right parameters, and it turns out all I really need to do is give the C# compiler some information to explicitly say yes, this AddGrade member that I'm defining, it overrides whatever my base class is providing. And this is really how we achieve polymorphism in C#, the ability to override methods that we inherit from a base class. Now you cannot just override any method that you inherit. You can only override abstract methods and methods that we call virtual methods, that's methods that are marked with a keyword in the C# language, the virtual keyword. I haven't shown you an example of that, but you'll be able to find lots of documentation on the matter. I'm just trying to focus on more common day to day cases that you'll run into. So one common case is you have an abstract base class, and you need to provide an implementation of an abstract member. That's where you can use the override key word. So now this Book class, everything compiles correctly, and I now have a Book class that will store all grades in memory, and now that I know that that is just one type of book that I might have, so I might have another type of book that stores grades in a file and another type of book that stores grades over the network in the Cloud somewhere. I now want to provide a more explicit name for this book. It's no longer just a simple generic book. It is a book that stores grades in memory. So I'm going to right‑click on this symbol and say that I want to rename the symbol. So in Visual Studio, this is the rename refactoring option. I went to rename Book to be InMemoryBook, and that just makes it very explicit. Anyone who is constructing this, they should expect to be holding the grades in memory. So if they need to store 5 trillion grades, that might not be something that they want to do in memory. They might want to choose a different class that stores grades on disk somewhere. And now that we've renamed this class to InMemoryBook, I'm going to go back to BookBase, so I'm going to rename this symbol to just Book, because, again, I don't like the word base in the class name. And really what I am trying to describe here are the basic members of a book. Every book should have a name. Every book should have the ability to add a grade. And now, if I save all my files, let's come back into program.cs, and I just want to show you that we're going to construct an instance of the InMemoryBook. We'll give it the name Scott's Grade Book. But what I want to take as a parameter to EnterGrades is just an object that is typed as Book. So, yes, that book might be an InMemoryBook or its actual runtime type might be another class that derives from the base Book class. I don't know. And when I call AddGrade, I'm not exactly sure what will happen to that grade, where it will go. All I know is that the behavior is polymorphic, and it might change depending on the actual type of the object that I'm working with. But whatever the type is, it is a book.

Defining an Interface
Another way to achieve encapsulation and polymorphism in C# is to define an interface type. An interface definition looks very much like a class definition, but an interface definition is pure. That is an interface contains no implementation details. So unlike an abstract class, which can contain actual methods and code and interface is only going to describe the members that should be available on a specific type. So the way I create an interface is to use the interface keyword and then, just like a class definition, I provide a name for this type. So yes, I'm defining a new type with an interface. And there will be a future release of the C# language that will allow you to specify some implementation details inside of an interface. But I'm going to stick with the common everyday use cases for an interface, which is I want to define a pure abstraction, no implementation details, but I want everyone to know what an IBook can do. So I want to define abstractly the members that will be available for anything that implements this interface, and I'll show you how to implement this interface in just a bit. But what are the things that I do in my application with anything that is a book? Well, one thing I do is add a grade. So I want the method, AddGrade, that takes a double parameter. Notice I do not use the public key word here because the assumption is that any object that implements this interface must have a member available named AddGrade, so that object must make this method available. So we will have that method. We also have a method that we use called GetStatistics. I'm going to make that method available on my interface. I'm also going to say that every IBook should have a property of type string, we'll call it Name, that's going to at least be a property that I can read. So it needs to have a getter. There might not be a setter, but this interface guarantees that there will be a getter. And finally, I want to make sure there is an event of type GradeAddedDelegate, which is named GradeAdded. So this is my interface. And why did I name it IBook? Well, there is a convention in C# and the .NET framework in general that any time you have an interface type, the name of that type will begin with an uppercase I. Not everyone follows that convention, but all the interfaces that are in the .NET framework follow this convention and there are many interfaces in the .NET framework. We'll be able to talk about just a few in this module. And I will just point out also that interfaces are far more common than abstract classes. So I guarantee that you'll run across interfaces that you use in day to day C# programming, but perhaps you won't use an abstract class every day. And so now the beauty of an interface is I want to have this interface to be able to express exactly what I require in particular bits of code. So, for example, inside of the EnterGrades method, I want to receive an object that will implement this IBook interface. I don't care about the ultimate type. I don't care how AddGrades behaves. I don't care how you calculate statistics. All I care is that the property, the event, and those two methods are going to be available on this object. And that will allow me to use code like book.AddGrade still. So I want to take a parameter of type IBook. But currently the C# compiler is going to say, I cannot pass you and InMemoryBook as an IBook because I don't know if a InMemoryBook implements that interface. When we were just using the base class book that was legal because the C# compiler can say, oh, an InMemoryBook is a specific type of book, and with the C# compiler you can always go from the more specific to the more general. But there is no relationship between InMemoryBook and IBook, currently. We're about to change that. So I can come over to my class, my InMemoryBook, and although I am not allowed to use multiple inheritance and specify multiple base classes, I can specify 0 or more interfaces that I want to implement. So I can specify 0 interfaces or 2 or 8 or 10, and I only want to specify 1 interface, which is IBook. So in a comma separated list, I can specify all the interfaces that I want to implement. And now the C# compiler is going to go through my class definition and make sure everything specified in the IBook interface is, in fact, implemented in this book, which it is. InMemoryBook already has the event, the property and these two methods. But let's say I want to make every book implement the IBook interface. In that case, I can remove the interface definition here and bring it up to my Book class and add it to my interface list. Now the C# compiler is going to have a problem because the C# compiler does not see a GradeAdded event in this abstract class, and it does not see a method name, GetStatistics in this class. When you say you're going to implement an interface, you must have those members in your class, even if they are abstract. So notice AddGrade is a method in this class, so there's not an error that I don't have an AddGrade method, even though that method is abstract, that's okay. Now, one easy way to add these members is to place the cursor on the symbol, press Ctrl+period, and I can say that I want to implement this interface. That will give me the event, GradeAdded. That's good. And let's also add the method, GetStatistics. By default, this will just throw an exception that says, sorry, I'm not implemented. And that's okay, I'm going to leave that alone and in there for right now. Now this has created some other problems in my code. So all of this works. I'm over in program.cs, the C# compiler will now say, oh yes, an InMemoryBook, it is a type of book, and every book implements IBook, so I'm going to allow this code through where you can pass book along to EnterGrades. But the C# compiler will complain a little bit because inside of InMemoryBook, I have these implementation details for GetStatistics and GradeAdded, but I've also inherited those members from my base class, so there already is an implementation of GetStatistics. And this is where I can use the virtual keyword. So the virtual keyword is a way in C# of saying, here's a method that's in this class, but a derived class might choose to override the implementation details for this method. So an abstract method is implicitly virtual because someone needs to provide an implementation and override this abstract method. Events and properties too can also be virtual. So I'm going to give this event the virtual keyword, and now inside of InMemoryBook, I can scroll down and I can say for GetStatistics, I want to override what's available in my base class, and for this event, I want to override the implementation in my base class. That might seem strange for an event where we only really have one line of code, but this is technically what we are doing. We are providing another implementation for this event, and we're overriding the implementation that's in the base class. So now I have this pure abstraction, this IBook interface that defines the capability of any book where I want to store grades and compute statistics. And we've been talking all this time about different types of books. So books that store grades in memory and books that can store grades on the file system on disk. And that's what you are going to do between now and the end of this module, you're going to implement another book type that will store grades into a file. Don't worry, I'm going to help you with this task and also provide some more design tips and best practices for C #, but that is the goal between now and the end of the module.

Writing Grades to a File
Ultimately, what we want to do in this module is build another class that will store grades on disk. So instead of an InMemoryBook, I want you to change this identifier to a DiskBook, so it's a book that is backed by disk storage. That class doesn't exist yet, but it's going to be your responsibility to first create it. You have to make sure that DiskBook ultimately somehow implements the IBook interface because IBook is really all we care about inside our Program.cs. IBook gives us all the abstractions that we need. It gives us the event, it gives us the methods, GetStatistics and AddGrade, and it also gives us the Name property. By the way, while we are in here we can remove this line of code that was only here to demonstrate what a const or a static field looks like, we can remove that noise, and now this is the first bit of code that I want you to have working. So your first goal is to create a class, DiskBook, that will implement IBook, and nothing has to work or compute any numbers, just try to reach the point where this project has no compiler errors. And so now I need a DiskBook class that will implement the IBook interface. So back in Book.cs, what I want to do is create another public class. We will call it DiskBook. And it is entirely legal for me to just go ahead and say this will implement the IBook interface. I'm not required to derive from any abstract base class, I can just go directly to that interface and implement that interface, but because this book abstract base class provides some existing code for me already, I will allow DiskBook to derive from that book. The next thing I would need to do, though, is provide the constructor that will call into one of the base class constructors to initialize the name. We've done this a couple times already. So I'm going to hit Ctrl+period and select the option to generate a constructor for my class that will take my name parameter and forward it to the base class constructor, so that's good. And now I can also hit Ctrl+period to implement my abstract class. Remember, my Book class has an abstract member, which is AddGrade, and if I'm going to build a class that is not an abstract class itself, it needs to implement every abstract member, but before I do that I actually want to add some additional abstract keywords to this class. What I was trying to demonstrate earlier is how you can combine virtual and abstract, and really an abstract method is a virtual method, but it's just a virtual method that has no implementation. But at this point, it doesn't make sense to have a method like GetStatistics that really is not implemented, at runtime it's always going to throw a not implemented exception, so it would make sense if I just marked this as an abstract method and force some derived class to provide an implementation for this method. It also doesn't quite make sense to have a GradeAdded event on this book, because the event is not used anywhere inside of this abstract class. So I'm also going to mark this member as abstract, which will again force a derived class like DiskBook to provide an implementation for GradeAdded, and that's exactly what I want. So now if I come to DiskBook and hit Ctrl+period, I can implement my abstract base class. That means I will have an event that overrides GradeAdded from the base class. I'll have an AddGrade method that is also an override of the base class and GetStatistics. Let's first focus on AddGrade. Here's your next challenge. I want you to write the code so that every time this method is invoked, the method will open a file that has the same name as the book and write a new line into the file that contains the grade value. Let me give you some help with this or at least a first pointer. There is a file class in .NET. This class lives in the system.io namespace, so you'll need to have a using statement for system.io, but once you do that, there are static methods available in this class that allow you to open and read and write into files. So the first method that appears here in the IntelliSense list is actually the method that you want to use. That's going to be the AppendText method. Now this method doesn't write into the file itself, all it simply does is open up a file given a name that you provide, and it returns an object that will automatically write to the end of that file. So given this little bit of a start, I want you to open a file that has the same name as the book, but with a .txt extension, and then get the program working to the point where you can write a single grade into that file. See what happens if you try to add a second grade to the file, but at least get the first grade into the file and then unpause the video and come right back. So if I want to open a file that has the same name as my book with a txt extension, I could use string interpolation to say open something that is name.txt, and I know that will return to me something that I can use to write into the file. So let's declare a variable named writer and see what we can do with this writer. So hopefully you were able to browse through the IntelliSense and find the helpful method WriteLine, which is exactly what you want to do, write a line into that file that will contain the grade value. That will go to the end of file, because everything is set up by AppendText so that that writer writes to the end of the file. Let's save everything and try this out from the command line. So I want to do a dotnet run on the project that is in the gradebook folder. Let me go ahead and press Return to start this running. We're not using the event GradeAdded yet, that's a warning, but that's okay, we will be using it eventually. For right now I just want to write my first grade into the file, so let's try a 90. And now let's try to write a second grade into the file, and oops, there's an exception. A system.io exception. The process cannot access the file Scott's Grade Book.txt because it's being used by another process. Why is this happening? Well, I can see in my folder there is Scott's Grade Book.txt. It has a final size of 0, so we did somehow manage to create that file, but we haven't actually written anything into it, and it seems impossible to write a second grade into that file. Let's talk about what went wrong in the next clip.

Using IDisposable
The problem with our software is that every time the AddGrade method is invoked, our code is going out to open a file for writing. And in general, once you open a file for writing, that file is locked and cannot be opened again. So trying to open the file a second time is going to throw an exception. There's two solutions to this problem. One solution would be to only open the file once and keep this file writer around as a field, as a member of this class, so I can access it again the next time we come into AddGrade and we don't try to open the file again. However, there's a bigger issue here, and that is when you open a file, you, in general, need to then close the file when you are finished using that file. That will flush all the data out of the file and make sure everything is written. The problem here would be what happens if we open the file, and then we go to write into the file, and something inside this code throws an exception. In that case, we wouldn't be closing the file. We would leave it open, and that can be a problem. So let me show you something interesting about this StreamWriter that is returned. I'm going to place the cursor here on AppendText and press the F12 key to go to the metadata definition. We've seen this before in this course. And then inside of this file, I'm going to go to the StreamWriter symbol, place the cursor there, and press F12 to go to the definition for StreamWriter. I can see that StreamWriter inherits from a base class, TextWriter. Again, I'm going to F12 on TextWriter to look at the definition of TextWriter, and I can see that this TextWriter is an abstract base class. I can browse through and look at the different abstract methods, but this is an example of an inheritance hierarchy in the .NET Framework and .NET Core that builds on top of an abstract class. This abstract class TextWriter can write text into various different streams. That stream might lead to a file in the filesystem or might be a stream that goes over a network or it might be a stream that remains in memory and just writes into a string. There's all sorts of different streams that I can write into, and this abstract class defines the behavior that I can use for all those streams. But what I really want to point out here is that this class implements an interface, which is IDisposable. And if we go to the definition for IDisposable, we can see there's one method defined, and that is the Dispose method. Look at the description here. This performs application‑defined tasks associated with freeing, releasing, or resetting unmanaged resources. So earlier in the course, I told you that there is a garbage collector in .NET and that you don't have to worry about releasing memory. So I can use the new keyword on as many class types as I need and construct new instances of objects, and the .NET runtime will figure out when I'm finished using those objects and will clean things up by running a garbage collector. However, I cannot determine exactly when the garbage collector will run to clean up the objects I'm no longer using, and there are some objects which acquire resources that we want to tell them to clean up as soon as possible. And those would be objects like an object that uses the operating system to open a file When I am finished writing into that file, I want to immediately tell that object to clean things up and close the file so that that file is unlocked and can be opened again just a few lines of code later if necessary. This IDisposable interface is the interface that many classes in .NET will implement to advertise the fact that they have something to clean up. They have something that needs to be freed or released. And the TextWriter that is returned from File.AppendText, this class ultimately implements IDisposable. So it's something I need to clean up. And yes, I can invoke instead of Writer.Close, I could also invoke Writer.Dispose. So you'll typically find this pattern on some classes and objects in .NET where they implement IDisposable so they will have a Dispose method. They might also have a Close method. And typically, those two methods do the same thing. They clean up and free the underlying resource, which in this case is probably a file handle from the filesystem. Regardless of which method I use, Close or Dispose, I want to make sure that method is always called, even if there is an exception here on the line of code that is doing a WriteLine. And it turns out there's an easy pattern you can follow to do this when you're programming with C# and you're working with an object that implements IDisposable. What you can do is wrap an IDisposable object with a using statement. So I'm going to use the using keyword here. And when I use the using keyword down here inside of a method, I am not bringing in a namespace. So this using keyword is overloaded in the C# language. If I have a using statement at the top of the file, that is to bring in a namespace like System.IO. But if I have the using keyword on a statement like this, I'm saying that I am using this writer, and I want you, the C# compiler, to make sure to clean things up when I am finished with this object. And I am finished with this object when I reach this closing curly brace. So I am using with every line of code that is in this scope denoted by the curly braces. And what the C# compiler will do is essentially generate a try‑finally statement like we've written before earlier in the course that will wrap all the code that is inside of here so that by the time we hit this closing curly brace, the C# compiler guarantees that it will call dispose on this IDisposable object. So this is a common pattern you'll see in .NET programming. When you're working with an object that works with things like files or sockets and has some underlying resource, we typically wrap those with a using statement so that we can create those objects and then dispose those objects as soon as we are finished working with them. And now I should be able to add as many grades as I want to the grade book, and I should also be able to raise the GradeAdded event after I write that grade. So let's check if GradeAdded, If it's not equal to null, what I want to do is again invoke GradeAdded, pass along myself as the sender of the event and a new instance of the EventArgs class. And that pretty much provides the implementation that we want for AddGrade. Now let's look at GetStatistics, which needs to read all of the grades that we've placed into that file.

A Statistical Challenge
Now that I've come to implement the GetStatistics method, I find myself in a bit of an unfortunate situation. It's unfortunate that I already have an implementation of GetStatistics that has been proven to be correct by a unit test, it does calculate the correct average, but currently, the way this method is implemented, I don't have a way to share this method with my other class, the DiskBook. All of this code assumes it can just reach into a list of grades to do the computation. So what I could do is copy all the code that is inside of GetStatistics and paste it into my other book class and then modify this to read grades from my file, instead of working with in‑memory list, but that, again, is an unfortunate solution because there is a lot of code in here that has nothing to do with working with an in‑memory list of grades, for example, all these cases where we're calculating the letter grade are buried inside of this method and I don't have a way to reach this code for my other class. So any time you go to copy and paste code, particularly, when you copy and paste multiple lines of code, you have to take a step back and think Is there a better solution? Is there are way I can provide more encapsulation? Is there a way I can reuse code? And in this case, I believe the answer is yes, absolutely. So one thing I would look at that is just something you pick up after you've been doing programming for a long time is the fact that there are a lot of decisions being made inside of GetStatistics and then those decisions are being pushed into results that are part of statistics. So earlier in the course, I said it was important to separate the signing from doing and it's important to provide proper encapsulation. So if I am producing a result from this method that is going to be a collection of numbers that represent the different statistics about my grades, then I went to have a dedicated type that will hold the results of those statistics, but even more than that, I want to revisit the Statistics class and figure out how I can place more code into the Statistics class and get rid of as much of this code as I can from inside of the InMemoryBook because the more code that I can place into the Statistics class, the more code that I can reuse from other classes that are working with grades. So what I want you to try as a final exercise for this course, is see how much code that you can get rid of from GetStatistics, see how much of this code you can place into the Statistics class. Let me give you a couple of tips. Code like this is initializing all the values that are on the Statistics class. That's really easy. This code should go into a constructor for statistics and be automatically executed when I invoke the new keyword. It's not the responsibility of these other classes to initialize statistics, that should happen automatically inside the Statistics class itself. Also, the Statistics class should be able to calculate an average if I just keep giving it every grade that I know about. So the Statistics class doesn't need to store grades, it can just store a running sum, an account of how many grades I've added to the class and that should be enough information for the Statistics class to compute an average, as well as a letter grade. I should be able to remove most of this code from inside of this method and still return a result and still be able to, from program.cs, say things like statistics.Low, .High, .Average, and .Letter. So I want all of this code to work, but I want it to work by reusing and sharing code from the Statistics class, share that code between InMemoryBook and the DiscBook. There is many different solutions to this. In the next clip, I'll show you my solution.

Refactoring Statistics
So let's start with the easy bit. These three lines of code belong in a constructor, so I'm going to cut them out of Book.cs, come over to Statistics, and I went to place the cursor here and use Ctrl+. to say generate the constructor for me. I'm going to paste that code in, and of course, we're not working with a result now. All I want to do is have the initialization code that sets the average, the high, and the low. So this is a good start. I've already removed three lines of code from GetStatistics. Now, how do I work with the average? Well again, if the Statistics class had a method that would allow me to add to a sum that it keeps, a running sum, then the Statistics class would be able to compute an average itself. So let's add another public property of type double to Statistics, we'll call it sum, and I'm going to explicitly initialize sum, to a 0.0 value. That's what would happen, by default, but let's just be explicit about it. And I'm also going to add an integer here, which is the count of things or the count of numbers that I've placed in. And once again I'll provide some explicit initialization and say, Count = 0. Now we just need a method to say add this number into the statistics. So let's create a method that has no return value. It's named Add and it just takes a number. Every time it receives a number, we say that the Sum += that number and the Count of how many numbers we know about is incremented by 1, and given that we now have a sum and we now have a count, I have an easy way to compute the average. I no longer want the outside code to compute an average and store it here. Instead, I'm going to turn this into a property that only has a getter. So this is a read only property. You cannot set the average anymore, but if you try to read the average, what I will do is return this total Sum that we've computed divided by the Count of the numbers you've placed in here and that will be your average. And that means back in Book.cs as I'm going through this loop, all I really need to do is say result please Add grades sub index. So please add this number and use that to compute the average. I no longer need to set the average. It will be computed for me. I don't need this line of code because result.Average will give me the average, but I do need to replicate this code inside of the Add method. So let me cut these two lines of code from Book.cs, Ctrl+X to cut those, come back to Statistics, and inside of the Add method, I will paste them, and I'm just going to fix things up so that low equals Math.Min, the result of using this number that was passed in and comparing it to my existing low value. Give me the minimum value of those two and the high property or the High field will equal Math.Max of number that was passed in and the current High value that I know about. So all we need to do here as I have a compiler error because the namespace for Math is not in scope. Let me just hit Ctrl+. and say yes, please add a using System statement at the top of this file, and now that code compiles. And now down here in the constructor, because previously I made Average a read‑only property, I can no longer set the average, and that's fine and it's going to be computed. I no longer need to write to that property any longer. So now this is looking pretty good. Over in Book.cs, I've removed a pretty good amount of code. And I've pushed all these calculations into the Statistics class where we can reuse them. What about the letter grade? Well, again, this is something that I could do inside of the Statistics class. So let me take this entire switch statement, I'm going to cut it with Ctrl+X, come back to Statistics.cs, and once again, we could have a property with letter, instead of just a field that computes the letter grade on the fly. So let me paste in the code that we have, and now we're just going to have to go through and fix some things up. So I want to have this in a getter. Let me undo that paste operation, Ctrl+Z. I want this inside of a getter for the letter property. Let me now paste in the switch statement. So again, coming back to the top, I'm going to tell Visual Studio code that I want to format this document, Shift+Alt+F that will line up my curly braces and it's easier for me to see where I am. And one thing I need to do is get rid of result, so I want to switch on the result of the average property. I no longer have a variable name of result. I just have a property named Average, so switch on the average value. And now, instead of trying to set result.Letter, let's just return this value. Let's just return an A if the average is greater than 90. When I have a return statement, I no longer need a break because the C# compiler can see that yes, you are escaping the switch statement so this is simplifying the code even more. When the grade is greater than 80, I'm going to replace this code with a return statement, and again, remove the break. When we're greater than 70, we will return a C. Let's remove the breaks statement. When we're greater than a 60, that will be a D and remove the break statement once again. And finally, the default for any other average is to return a letter grade of F. And this is a beautiful refactoring because now I've placed code inside of the Statistics class and it just feels right because the Book class has been so simplified, this GetStatistics method is so simplified, all this class cares about is how do I move through my collection of grades, in this case, I just walk through an in‑memory list, and all the hard work, all the mathematical operations happen inside of the Statistics class. Let's look at how we can use that Statistics class now from inside of DiskBook. So what we need to do is open our file and read the grades out and do the same computation or use statistics in the same way. Why don't you try to do this first and then pause the video and come right back when you think you have a solution. My only one tip will be that you can open a file for reading using File.OpenText and passing in a file name, so give it a try now. For my solution, I know that I want a result that will be an instance of the Statistics class. So I will go ahead and create that, and actually, as the last line of code, return that result. In between, what I need to do is first open the file. I will again use a using statement because when I open the file, I want to make sure that I close the file when I'm finished reading it. So let's declare a variable named reader and use File.OpenText to open the file that has the correct name, so the name of the grade book and then the .txt extension. With the using statement, I can define a block of code where I'm going to use that reader, and I can be sure it'll be cleaned up and the file is closed before we exit this method. So hopefully you looked at the reader and you were able to find a method that will help you read each grade that is inside because there is a method, ReadLine that will read a single line from the file and then move forward to the next time you call ReadLine, you'll read the next line, and you might notice in the description for ReadLine that you will receive the next line from the input stream or null if the end of the input stream is reached. So essentially, what we have to do instead of looping through a list, we have to loop through this file and use ReadLine to read each grade into memory. So let's first of all, store the result of ReadLine into a variable, and since we need a loop, let's say, while line is not equal to null because when line becomes null, we know we have reached the end of the file. Now we can take that line and parse it into a number just like we do in program.cs when the user types in a number, we have to parse the number because it arrives as a string, so we parse the number and turn it into a double. Let's declare a variable number, which will be the result of using double.Parse on the line that we read from the file, and if that works, we have a number. So let's use result.Add to add that number to our statistics and then read the next line and start the loop over so reader.read line. If that returns null, we'll go back to the top of the loop and the variable will be null and we'll exit out of the loop and return a result. All of this should just work. Let me save out the file. So let's come out to the command prompt and let's try a dotnet run on the project, which is GradeBook. I can enter a grade, let's enter a grade of 100 and a 90, and this is good because I'm entering multiple grades so our using statement must be working. And let's add one more grade of a 97 and then press Q to quit and I can see the lowest grade is 75, highest is 100, the letter grade is A, all of this works correct, and I should also be able to see in this folder Scott's Grade Book.txt. I should be able to type out the contents of that file and see all the grades I entered in that file. Now if I run this program again, what's going to happen, it's going to open this file, and it's going to keep appending grades so I can add as many grades I want and keep running this program to add more grades or I could delete this file and start from scratch, but we now have a grade book, we've done some refactoring, and we've seen how to do some object‑oriented programming.

Summary
In this module, we covered a variety of topics, including how to build an interface, how to define an abstract base class, how to introduce polymorphism and inheritance into a C# application. But I hope the big lesson that you took away is that encapsulation, once again, is the key to building good software. When you have the right level of encapsulation, your software becomes easier to work with. Yes, I could've copied and pasted code inside of my two different Book classes and come up with two different techniques for computing an average grade, but by giving that Statistics class the right level of encapsulation, I was able to offload a lot of that work in the code that I could reuse. And I want to point out that I can reuse that code without having an inheritance relationship between any of the Book classes and statistics. All I do is use the Statistics class from my other Book classes.

Catching up with the Latest in C#
Introduction
Hi, this is Scott, and I am recording this module sometime in the future, after all the previous modules have been recorded, because the C# language is always evolving. And in this module, I want to cover any significant changes that may be impacting the code you write for this course.

Working with Non-nullable Reference Types
Early in this course, you might remember we wrote code that generated a NullReferenceException at runtime. We had a NullReferenceException because there was an uninitialized field inside of the Book class. Now one significant addition to the C# language is an addition that is designed to help prevent NullReferenceExceptions at runtime. So this is a new feature that was added to the C# compiler that will allow us to work with what we call non‑nullable reference types. And the C# compiler can now aggressively look through our programs to try to find places where we might have a NullReferenceException at runtime. So first, I want to show you how this feature works, and then I went to explore some of the settings that have to be in place for this feature to work. So let's go over to Book.cs, and I'm using the code that I have at the end of the course. But in this code, there is still a grades field. So at the bottom of this class definition, I have a field named grades that is of type List<double>, and up here in the constructor for this class, I'm going to comment out the line of code that initializes this field. So in the course, this is effectively the code we had. We were working with a class that included a field that was never initialized. There were no warnings or errors from the compiler. And when we ran the program, the program crashed with a NullReferenceException. But now if I have this uninitialized field, let me show you what happens if I do a dotnet build. So keep in mind, I'm using a preview version of the C# 8 compiler and the .NET Core tools. So some things may change between the time I record this and the time you view the video. If there's anything significant, I plan on rerecording this module. But what I want to show you is running dotnet build now produces a warning. So this is a warning, not an error message, but the warning is that the non‑nullable field grades is uninitialized. So now, the C# compiler is smart enough to detect this possible situation where I might have something go wrong where I might be using grades because I've never initialized it, and I've never assigned to it. And because of that, the C# compiler can issue another warning that grades will always have its default value, which is null. Now if you've reached the point in the course where we talk about reference types and value types, then you know that when you have a field or a variable declared as a reference type, which List<double> is, then that field or variable typically contains a reference or a pointer to an object in memory. But the null value means that this field or this variable does not point to any object. It doesn't refer to anything, and therefore, if I try to interact with that field or variable by doing something like grades.Add and trying to invoke a member on an object instance, that's going to throw an exception because grades does not point to an object. That's just going to be an error, and it's going to crash the program. On the other hand, if I restore this line of code, so I am now initializing grades in the constructor, I could also use this expression new List<double> as a field initializer and just say grades = new List<double>. It would work there, too. As long as I had that in place and I do a dotnet build, the C# compiler can analyze my program and come back and say build succeeded. Now I'm temporarily going to switch over into Visual Studio 2019 not because there are features that are only available in Visual Studio 2019, but because only Visual Studio 19, a preview currently, will be able to show some of these warnings in the editor as I type. Let's take line 10 of Program.cs, for example. This is very similar to the code that we wrote earlier in the course. I'm just using some of the new capabilities that don't become present until you reach the end of the course, but let's try to say that book equals and a null value. If I do a build now, either from the command line or here in Visual Studio, once again, I will receive a warning, and I'm going to point out again, it's a warning not an error, that in this case, I'm converting a null literal or possible null value to a non‑nullable type. So the real core feature that we're talking about in C# version 8 is that when I work with reference types, I can make them nonnullable by default. So that includes existing reference types that are built into the .NET Framework, as well as custom reference types that I create, like book. So if I write a class definition, it's nonnullable by default. And the C# compiler can now analyze my program and tell me when I might be potentially assigning null or using something that is null. So you might notice on line 12, I also have a warning, and this is possible dereference of a null reference. So that's telling me you might be throwing a NullReferenceException on this line of code. Also, let's invoke the method EnterGrades, which takes an object that implements the IBook interface, and I'm going to pass null to that method. And once again, the C# compiler can give me a warning that I cannot convert a null literal to a non‑nullable reference. Now by the time you watch this, if you're using tools that are already using the released version of the C# 8 compiler or something released even later, this will be the default behavior. By default, reference types will be nonnullable. However, you can control this behavior by placing some flags into your csproj file. So remember, a csproj file is the project file. It's the file that contains all the settings about how to build and put together this project. And there's two settings in here that I went to call attention to. First of all, the LangVersion setting. Notice, I have my LangVersion set to 8.0. That is to ensure that I'm using version 8 of the C# language. And then the next setting is the NullableContextOptions. I want to enable NullableContextOptions to have the behavior that I'm describing here, where I have non‑nullable reference types. If this setting is not here, and this setting should be here if you're creating a brand new project using the latest tools, but if that setting is not there, this behavior goes away. So look at how all my warnings have disappeared. I can now legally assign null to my book variable, and I can invoke the method EnterGrades without a warning and passing along a null. Would I want to do that? Probably not because at runtime this can only create problems. So I'm going to go back to the csproj file and hit Ctrl+Z to undo my change, place that flag back in there, and the warnings will come back. So let's say you're writing a program where you really do want to use null values. Some people like to use null values to represent the absence of information. What happens, for example, if you want to represent a completely empty or non‑existent book? Well, if that's really what you want to do, you can use a ? to say that actually, this book variable is a nullable reference type of book. So, yes, I can place books into this variable, and I can say something like, I want a new InMemoryBook, and give it some name, and I can legally assign that object instance into my book variable. But I can also legally assign a null value and not receive a warning because I'm saying this variable is typed as something that can hold nulls. So the question mark will allow me to do that. Same thing with the IBook method. Let's say I implemented this method in a way that I check for nulls. So if someone does pass me a null value, I'm prepared to handle that. In that case, I can once again use the question mark and say, well, pass me a book or pass me null. I can work in either of those cases. Now there are more subtleties to these non‑nullable reference types, but the big picture here is that the designers of the C# language are trying to help you identify and eliminate a common source of errors and software over the years, that common source of errors being working with variables and fields that are not pointing to an actual object and getting a NullReferenceException. This feature should allow you to find potential places where that can happen and eliminate them.

Summary
In this module, we looked at non‑nullable reference types in C# version 8, and there're many other new features and areas of the C# language that I could talk about, but I'm going to leave it for the next module to give you some of the additional areas that you should explore by using other courses here, at Pluralsight.

Going Further with C#
Introduction
Hi. This is Scott. And in this last module, I went to give you some additional topics you can learn and courses you can watch to continue your journey with the C# language. Although I gave you all the fundamentals of C# in this course, the C# language is quite sophisticated, and there's always more to learn.

Generics
One topic that I suggest you explore further is the topic of generics in C#. We've already used some generics in the C# Fundamentals course. When we stored the grades inside of a book, we used a data structure known as a list of double, where the double was what we call a generic type parameter. These type parameters, and generics in general, are very important to understand if you're going to work with the C# language. It just so happens that I have a course, C# Generics, on Pluralsight.com, and this course will look at some of the built‑in generic collections, like list of T in the .NET Framework, as well as talk about generic classes, interfaces, and delegates.

Async C#
Asynchronous programming with C# is another important topic you should look at in more detail. On Pluralsight.com, John Skeet has a course, Asynchronous C#. In this course, you'll learn about the async and await keywords in the language, as well as how to do parallel processing and testing asynchronous code.

LINQ
Another important topic for C# is LINQ, that is, Language Integrated Query. When Microsoft introduced the LINQ query syntax to the C# language, they brought in some of the biggest changes to the language since the language was invented. In the course, I'm going to show you that the features added to the language to support LINQ go far beyond what is needed to just query data. We're going to look at some of the changes that were made that can really influence day‑to‑day programming with the C# language.

Effective C#
One last course I want to call your attention to is my course, C# Programming Paradigms. What you can do in this course is focus on just the last three modules, Object Oriented Programming with C#, Functional Programming with C#, and Crafting C# Code. I've always felt that these three modules in this course were some of the best material I've ever recorded about the C# language. These modules are based on some real‑world experiences with large projects where I found software design to be challenging. So once you have a firm grasp of all the C# fundamentals, as well as some of the other topics like LINQ and generics, then this course is really designed to go one step further, how do you design and solve hard problems using the C# language?